[
	{
		"section": "1 Synopsis\nffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...\n\n"
	},
	{
		"section": "2 Description\nffmpeg is a universal media converter. It can read a wide variety of\ninputs - including live grabbing/recording devices - filter, and transcode them\ninto a plethora of output formats.\n\nffmpeg reads from an arbitrary number of input \"files\" (which can be regular\nfiles, pipes, network streams, grabbing devices, etc.), specified by the\n-i option, and writes to an arbitrary number of output \"files\", which are\nspecified by a plain output url. Anything found on the command line which\ncannot be interpreted as an option is considered to be an output url.\n\nEach input or output url can, in principle, contain any number of streams of\ndifferent types (video/audio/subtitle/attachment/data). The allowed number and/or\ntypes of streams may be limited by the container format. Selecting which\nstreams from which inputs will go into which output is either done automatically\nor with the -map option (see the Stream selection chapter).\n\nTo refer to input files in options, you must use their indices (0-based). E.g.\nthe first input file is 0, the second is 1, etc. Similarly, streams\nwithin a file are referred to by their indices. E.g. 2:3 refers to the\nfourth stream in the third input file. Also see the Stream specifiers chapter.\n\nAs a general rule, options are applied to the next specified\nfile. Therefore, order is important, and you can have the same\noption on the command line multiple times. Each occurrence is\nthen applied to the next input or output file.\nExceptions from this rule are the global options (e.g. verbosity level),\nwhich should be specified first.\n\nDo not mix input and output files – first specify all input files, then all\noutput files. Also do not mix options which belong to different files. All\noptions apply ONLY to the next input or output file and are reset between files.\n\nSome simple examples follow.\n\n\n Convert an input media file to a different format, by re-encoding media streams:\n\nffmpeg -i input.avi output.mp4\n\n Set the video bitrate of the output file to 64 kbit/s:\n\nffmpeg -i input.avi -b:v 64k -bufsize 64k output.mp4\n\n Force the frame rate of the output file to 24 fps:\n\nffmpeg -i input.avi -r 24 output.mp4\n\n Force the frame rate of the input file (valid for raw formats only) to 1 fps and\nthe frame rate of the output file to 24 fps:\n\nffmpeg -r 1 -i input.m2v -r 24 output.mp4\n\n\nThe format option may be needed for raw input files.\n\n"
	},
	{
		"3 Detailed description": "3 Detailed description\nThe transcoding process in ffmpeg for each output can be described by\nthe following diagram:\n\n _______              ______________\n|       |            |              |\n| input |  demuxer   | encoded data |   decoder\n| file  | ---------> | packets      | -----+\n|_______|            |______________|      |\n                                           v\n                                       _________\n                                      |         |\n                                      | decoded |\n                                      | frames  |\n                                      |_________|\n ________             ______________       |\n|        |           |              |      |\n| output | <-------- | encoded data | <----+\n| file   |   muxer   | packets      |   encoder\n|________|           |______________|\n\n\n\nffmpeg calls the libavformat library (containing demuxers) to read\ninput files and get packets containing encoded data from them. When there are\nmultiple input files, ffmpeg tries to keep them synchronized by\ntracking lowest timestamp on any active input stream.\n\nEncoded packets are then passed to the decoder (unless streamcopy is selected\nfor the stream, see further for a description). The decoder produces\nuncompressed frames (raw video/PCM audio/...) which can be processed further by\nfiltering (see next section). After filtering, the frames are passed to the\nencoder, which encodes them and outputs encoded packets. Finally, those are\npassed to the muxer, which writes the encoded packets to the output file.\n\n",
		"3.1 Filtering": "3.1 Filtering\nBefore encoding, ffmpeg can process raw audio and video frames using\nfilters from the libavfilter library. Several chained filters form a filter\ngraph. ffmpeg distinguishes between two types of filtergraphs:\nsimple and complex.\n\n\n3.1.1 Simple filtergraphs\nSimple filtergraphs are those that have exactly one input and output, both of\nthe same type. In the above diagram they can be represented by simply inserting\nan additional step between decoding and encoding:\n\n _________                        ______________\n|         |                      |              |\n| decoded |                      | encoded data |\n| frames  |\\                   _ | packets      |\n|_________| \\                  /||______________|\n             \\   __________   /\n  simple     _\\||          | /  encoder\n  filtergraph   | filtered |/\n                | frames   |\n                |__________|\n\n\nSimple filtergraphs are configured with the per-stream -filter option\n(with -vf and -af aliases for video and audio respectively).\nA simple filtergraph for video can look for example like this:\n\n _______        _____________        _______        ________\n|       |      |             |      |       |      |        |\n| input | ---> | deinterlace | ---> | scale | ---> | output |\n|_______|      |_____________|      |_______|      |________|\n\n\nNote that some filters change frame properties but not frame contents. E.g. the\nfps filter in the example above changes number of frames, but does not\ntouch the frame contents. Another example is the setpts filter, which\nonly sets timestamps and otherwise passes the frames unchanged.\n\n\n3.1.2 Complex filtergraphs\nComplex filtergraphs are those which cannot be described as simply a linear\nprocessing chain applied to one stream. This is the case, for example, when the graph has\nmore than one input and/or output, or when output stream type is different from\ninput. They can be represented with the following diagram:\n\n _________\n|         |\n| input 0 |\\                    __________\n|_________| \\                  |          |\n             \\   _________    /| output 0 |\n              \\ |         |  / |__________|\n _________     \\| complex | /\n|         |     |         |/\n| input 1 |---->| filter  |\\\n|_________|     |         | \\   __________\n               /| graph   |  \\ |          |\n              / |         |   \\| output 1 |\n _________   /  |_________|    |__________|\n|         | /\n| input 2 |/\n|_________|\n\n\nComplex filtergraphs are configured with the -filter_complex option.\nNote that this option is global, since a complex filtergraph, by its nature,\ncannot be unambiguously associated with a single stream or file.\n\nThe -lavfi option is equivalent to -filter_complex.\n\nA trivial example of a complex filtergraph is the overlay filter, which\nhas two video inputs and one video output, containing one video overlaid on top\nof the other. Its audio counterpart is the amix filter.\n\n",
		"3.2 Stream copy": "3.2 Stream copy\nStream copy is a mode selected by supplying the copy parameter to the\n-codec option. It makes ffmpeg omit the decoding and encoding\nstep for the specified stream, so it does only demuxing and muxing. It is useful\nfor changing the container format or modifying container-level metadata. The\ndiagram above will, in this case, simplify to this:\n\n _______              ______________            ________\n|       |            |              |          |        |\n| input |  demuxer   | encoded data |  muxer   | output |\n| file  | ---------> | packets      | -------> | file   |\n|_______|            |______________|          |________|\n\n\nSince there is no decoding or encoding, it is very fast and there is no quality\nloss. However, it might not work in some cases because of many factors. Applying\nfilters is obviously also impossible, since filters work on uncompressed data.\n\n",
		"3.3 Loopback decoders": "3.3 Loopback decoders\nWhile decoders are normally associated with demuxer streams, it is also possible\nto create \"loopback\" decoders that decode the output from some encoder and allow\nit to be fed back to complex filtergraphs. This is done with the -dec\ndirective, which takes as a parameter the index of the output stream that should\nbe decoded. Every such directive creates a new loopback decoder, indexed with\nsuccessive integers starting at zero. These indices should then be used to refer\nto loopback decoders in complex filtergraph link labels, as described in the\ndocumentation for -filter_complex.\n\nDecoding AVOptions can be passed to loopback decoders by placing them before\n-dec, analogously to input/output options.\n\nE.g. the following example:\n\n\nffmpeg -i INPUT                                        \\\n  -map 0:v:0 -c:v libx264 -crf 45 -f null -            \\\n  -threads 3 -dec 0:0                                  \\\n  -filter_complex '[0:v][dec:0]hstack[stack]'          \\\n  -map '[stack]' -c:v ffv1 OUTPUT\n\nreads an input video and\n\n\n (line 2) encodes it with libx264 at low quality;\n\n (line 3) decodes this encoded stream using 3 threads;\n\n (line 4) places decoded video side by side with the original input video;\n\n (line 5) combined video is then losslessly encoded and written into\nOUTPUT.\n\n\n"
	},
	{
		"4 Stream selection": "4 Stream selection\nffmpeg provides the -map option for manual control of stream selection in each\noutput file. Users can skip -map and let ffmpeg perform automatic stream selection as\ndescribed below. The -vn / -an / -sn / -dn options can be used to skip inclusion of\nvideo, audio, subtitle and data streams respectively, whether manually mapped or automatically\nselected, except for those streams which are outputs of complex filtergraphs.\n\n",
		"4.1 Description": "4.1 Description\nThe sub-sections that follow describe the various rules that are involved in stream selection.\nThe examples that follow next show how these rules are applied in practice.\n\nWhile every effort is made to accurately reflect the behavior of the program, FFmpeg is under\ncontinuous development and the code may have changed since the time of this writing.\n\n\n4.1.1 Automatic stream selection\nIn the absence of any map options for a particular output file, ffmpeg inspects the output\nformat to check which type of streams can be included in it, viz. video, audio and/or\nsubtitles. For each acceptable stream type, ffmpeg will pick one stream, when available,\nfrom among all the inputs.\n\nIt will select that stream based upon the following criteria:\n\n\n for video, it is the stream with the highest resolution,\n for audio, it is the stream with the most channels,\n for subtitles, it is the first subtitle stream found but there’s a caveat.\nThe output format’s default subtitle encoder can be either text-based or image-based,\nand only a subtitle stream of the same type will be chosen.\n\nIn the case where several streams of the same type rate equally, the stream with the lowest\nindex is chosen.\n\nData or attachment streams are not automatically selected and can only be included\nusing -map.\n\n\n4.1.2 Manual stream selection\nWhen -map is used, only user-mapped streams are included in that output file,\nwith one possible exception for filtergraph outputs described below.\n\n\n4.1.3 Complex filtergraphs\nIf there are any complex filtergraph output streams with unlabeled pads, they will be added\nto the first output file. This will lead to a fatal error if the stream type is not supported\nby the output format. In the absence of the map option, the inclusion of these streams leads\nto the automatic stream selection of their types being skipped. If map options are present,\nthese filtergraph streams are included in addition to the mapped streams.\n\nComplex filtergraph output streams with labeled pads must be mapped once and exactly once.\n\n\n4.1.4 Stream handling\nStream handling is independent of stream selection, with an exception for subtitles described\nbelow. Stream handling is set via the -codec option addressed to streams within a\nspecific output file. In particular, codec options are applied by ffmpeg after the\nstream selection process and thus do not influence the latter. If no -codec option is\nspecified for a stream type, ffmpeg will select the default encoder registered by the output\nfile muxer.\n\nAn exception exists for subtitles. If a subtitle encoder is specified for an output file, the\nfirst subtitle stream found of any type, text or image, will be included. ffmpeg does not validate\nif the specified encoder can convert the selected stream or if the converted stream is acceptable\nwithin the output format. This applies generally as well: when the user sets an encoder manually,\nthe stream selection process cannot check if the encoded stream can be muxed into the output file.\nIf it cannot, ffmpeg will abort and all output files will fail to be processed.\n\n",
		"4.2 Examples": "4.2 Examples\nThe following examples illustrate the behavior, quirks and limitations of ffmpeg’s stream\nselection methods.\n\nThey assume the following three input files.\n\n\ninput file 'A.avi'\n      stream 0: video 640x360\n      stream 1: audio 2 channels\n\ninput file 'B.mp4'\n      stream 0: video 1920x1080\n      stream 1: audio 2 channels\n      stream 2: subtitles (text)\n      stream 3: audio 5.1 channels\n      stream 4: subtitles (text)\n\ninput file 'C.mkv'\n      stream 0: video 1280x720\n      stream 1: audio 2 channels\n      stream 2: subtitles (image)\n\n\nExample: automatic stream selection\n\nffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov\n\nThere are three output files specified, and for the first two, no -map options\nare set, so ffmpeg will select streams for these two files automatically.\n\nout1.mkv is a Matroska container file and accepts video, audio and subtitle streams,\nso ffmpeg will try to select one of each type.\nFor video, it will select stream 0 from B.mp4, which has the highest\nresolution among all the input video streams.\nFor audio, it will select stream 3 from B.mp4, since it has the greatest\nnumber of channels.\nFor subtitles, it will select stream 2 from B.mp4, which is the first subtitle\nstream from among A.avi and B.mp4.\n\nout2.wav accepts only audio streams, so only stream 3 from B.mp4 is\nselected.\n\nFor out3.mov, since a -map option is set, no automatic stream selection will\noccur. The -map 1:a option will select all audio streams from the second input\nB.mp4. No other streams will be included in this output file.\n\nFor the first two outputs, all included streams will be transcoded. The encoders chosen will\nbe the default ones registered by each output format, which may not match the codec of the\nselected input streams.\n\nFor the third output, codec option for audio streams has been set\nto copy, so no decoding-filtering-encoding operations will occur, or can occur.\nPackets of selected streams shall be conveyed from the input file and muxed within the output\nfile.\n\n\nExample: automatic subtitles selection\n\nffmpeg -i C.mkv out1.mkv -c:s dvdsub -an out2.mkv\n\nAlthough out1.mkv is a Matroska container file which accepts subtitle streams, only a\nvideo and audio stream shall be selected. The subtitle stream of C.mkv is image-based\nand the default subtitle encoder of the Matroska muxer is text-based, so a transcode operation\nfor the subtitles is expected to fail and hence the stream isn’t selected. However, in\nout2.mkv, a subtitle encoder is specified in the command and so, the subtitle stream is\nselected, in addition to the video stream. The presence of -an disables audio stream\nselection for out2.mkv.\n\n\nExample: unlabeled filtergraph outputs\n\nffmpeg -i A.avi -i C.mkv -i B.mp4 -filter_complex \"overlay\" out1.mp4 out2.srt\n\nA filtergraph is setup here using the -filter_complex option and consists of a single\nvideo filter. The overlay filter requires exactly two video inputs, but none are\nspecified, so the first two available video streams are used, those of A.avi and\nC.mkv. The output pad of the filter has no label and so is sent to the first output file\nout1.mp4. Due to this, automatic selection of the video stream is skipped, which would\nhave selected the stream in B.mp4. The audio stream with most channels viz. stream 3\nin B.mp4, is chosen automatically. No subtitle stream is chosen however, since the MP4\nformat has no default subtitle encoder registered, and the user hasn’t specified a subtitle encoder.\n\nThe 2nd output file, out2.srt, only accepts text-based subtitle streams. So, even though\nthe first subtitle stream available belongs to C.mkv, it is image-based and hence skipped.\nThe selected stream, stream 2 in B.mp4, is the first text-based subtitle stream.\n\n\nExample: labeled filtergraph outputs\n\nffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex \"[1:v]hue=s=0[outv];overlay;aresample\" \\\n       -map '[outv]' -an        out1.mp4 \\\n                                out2.mkv \\\n       -map '[outv]' -map 1:a:0 out3.mkv\n\nThe above command will fail, as the output pad labelled [outv] has been mapped twice.\nNone of the output files shall be processed.\n\n\nffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex \"[1:v]hue=s=0[outv];overlay;aresample\" \\\n       -an        out1.mp4 \\\n                  out2.mkv \\\n       -map 1:a:0 out3.mkv\n\nThis command above will also fail as the hue filter output has a label, [outv],\nand hasn’t been mapped anywhere.\n\nThe command should be modified as follows,\n\n\nffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex \"[1:v]hue=s=0,split=2[outv1][outv2];overlay;aresample\" \\\n        -map '[outv1]' -an        out1.mp4 \\\n                                  out2.mkv \\\n        -map '[outv2]' -map 1:a:0 out3.mkv\n\nThe video stream from B.mp4 is sent to the hue filter, whose output is cloned once using\nthe split filter, and both outputs labelled. Then a copy each is mapped to the first and third\noutput files.\n\nThe overlay filter, requiring two video inputs, uses the first two unused video streams. Those\nare the streams from A.avi and C.mkv. The overlay output isn’t labelled, so it is\nsent to the first output file out1.mp4, regardless of the presence of the -map option.\n\nThe aresample filter is sent the first unused audio stream, that of A.avi. Since this filter\noutput is also unlabelled, it too is mapped to the first output file. The presence of -an\nonly suppresses automatic or manual stream selection of audio streams, not outputs sent from\nfiltergraphs. Both these mapped streams shall be ordered before the mapped stream in out1.mp4.\n\nThe video, audio and subtitle streams mapped to out2.mkv are entirely determined by\nautomatic stream selection.\n\nout3.mkv consists of the cloned video output from the hue filter and the first audio\nstream from B.mp4.\n\n\n"
	},
	{
		"5 Options": "5 Options\nAll the numerical options, if not specified otherwise, accept a string\nrepresenting a number as input, which may be followed by one of the SI\nunit prefixes, for example: ’K’, ’M’, or ’G’.\n\nIf ’i’ is appended to the SI unit prefix, the complete prefix will be\ninterpreted as a unit prefix for binary multiples, which are based on\npowers of 1024 instead of powers of 1000. Appending ’B’ to the SI unit\nprefix multiplies the value by 8. This allows using, for example:\n’KB’, ’MiB’, ’G’ and ’B’ as number suffixes.\n\nOptions which do not take arguments are boolean options, and set the\ncorresponding value to true. They can be set to false by prefixing\nthe option name with \"no\". For example using \"-nofoo\"\nwill set the boolean option with name \"foo\" to false.\n\nOptions that take arguments support a special syntax where the argument given on\nthe command line is interpreted as a path to the file from which the actual\nargument value is loaded. To use this feature, add a forward slash ’/’\nimmediately before the option name (after the leading dash). E.g.\n\n\nffmpeg -i INPUT -/filter:v filter.script OUTPUT\n\nwill load a filtergraph description from the file named filter.script.\n\n\n",
		"5.1 Stream specifiers": "5.1 Stream specifiers\nSome options are applied per-stream, e.g. bitrate or codec. Stream specifiers\nare used to precisely specify which stream(s) a given option belongs to.\n\nA stream specifier is a string generally appended to the option name and\nseparated from it by a colon. E.g. -codec:a:1 ac3 contains the\na:1 stream specifier, which matches the second audio stream. Therefore, it\nwould select the ac3 codec for the second audio stream.\n\nA stream specifier can match several streams, so that the option is applied to all\nof them. E.g. the stream specifier in -b:a 128k matches all audio\nstreams.\n\nAn empty stream specifier matches all streams. For example, -codec copy\nor -codec: copy would copy all the streams without reencoding.\n\nPossible forms of stream specifiers are:\n\n\nstream_index\nMatches the stream with this index. E.g. -threads:1 4 would set the\nthread count for the second stream to 4. If stream_index is used as an\nadditional stream specifier (see below), then it selects stream number\nstream_index from the matching streams. Stream numbering is based on the\norder of the streams as detected by libavformat except when a stream group\nspecifier or program ID is also specified. In this case it is based on the\nordering of the streams in the group or program.\n\nstream_type[:additional_stream_specifier]\nstream_type is one of following: ’v’ or ’V’ for video, ’a’ for audio, ’s’\nfor subtitle, ’d’ for data, and ’t’ for attachments. ’v’ matches all video\nstreams, ’V’ only matches video streams which are not attached pictures, video\nthumbnails or cover arts. If additional_stream_specifier is used, then\nit matches streams which both have this type and match the\nadditional_stream_specifier. Otherwise, it matches all streams of the\nspecified type.\n\ng:group_specifier[:additional_stream_specifier]\nMatches streams which are in the group with the specifier group_specifier.\nif additional_stream_specifier is used, then it matches streams which both\nare part of the group and match the additional_stream_specifier.\ngroup_specifier may be one of the following:\n\ngroup_index\nMatch the stream with this group index.\n\n#group_id or i:group_id\nMatch the stream with this group id.\n\n\n\np:program_id[:additional_stream_specifier]\nMatches streams which are in the program with the id program_id. If\nadditional_stream_specifier is used, then it matches streams which both\nare part of the program and match the additional_stream_specifier.\n\n\n#stream_id or i:stream_id\nMatch the stream by stream id (e.g. PID in MPEG-TS container).\n\nm:key[:value]\nMatches streams with the metadata tag key having the specified value. If\nvalue is not given, matches streams that contain the given tag with any\nvalue.\n\nu\nMatches streams with usable configuration, the codec must be defined and the\nessential information such as video dimension or audio sample rate must be present.\n\nNote that in ffmpeg, matching by metadata will only work properly for\ninput files.\n\n\n",
		"5.2 Generic options": "5.2 Generic options\nThese options are shared amongst the ff* tools.\n\n\n-L\nShow license.\n\n\n-h, -?, -help, --help [arg]\nShow help. An optional parameter may be specified to print help about a specific\nitem. If no argument is specified, only basic (non advanced) tool\noptions are shown.\n\nPossible values of arg are:\n\nlong\nPrint advanced tool options in addition to the basic tool options.\n\n\nfull\nPrint complete list of options, including shared and private options\nfor encoders, decoders, demuxers, muxers, filters, etc.\n\n\ndecoder=decoder_name\nPrint detailed information about the decoder named decoder_name. Use the\n-decoders option to get a list of all decoders.\n\n\nencoder=encoder_name\nPrint detailed information about the encoder named encoder_name. Use the\n-encoders option to get a list of all encoders.\n\n\ndemuxer=demuxer_name\nPrint detailed information about the demuxer named demuxer_name. Use the\n-formats option to get a list of all demuxers and muxers.\n\n\nmuxer=muxer_name\nPrint detailed information about the muxer named muxer_name. Use the\n-formats option to get a list of all muxers and demuxers.\n\n\nfilter=filter_name\nPrint detailed information about the filter named filter_name. Use the\n-filters option to get a list of all filters.\n\n\nbsf=bitstream_filter_name\nPrint detailed information about the bitstream filter named bitstream_filter_name.\nUse the -bsfs option to get a list of all bitstream filters.\n\n\nprotocol=protocol_name\nPrint detailed information about the protocol named protocol_name.\nUse the -protocols option to get a list of all protocols.\n\n\n\n-version\nShow version.\n\n\n-buildconf\nShow the build configuration, one option per line.\n\n\n-formats\nShow available formats (including devices).\n\n\n-demuxers\nShow available demuxers.\n\n\n-muxers\nShow available muxers.\n\n\n-devices\nShow available devices.\n\n\n-codecs\nShow all codecs known to libavcodec.\n\nNote that the term ’codec’ is used throughout this documentation as a shortcut\nfor what is more correctly called a media bitstream format.\n\n\n-decoders\nShow available decoders.\n\n\n-encoders\nShow all available encoders.\n\n\n-bsfs\nShow available bitstream filters.\n\n\n-protocols\nShow available protocols.\n\n\n-filters\nShow available libavfilter filters.\n\n\n-pix_fmts\nShow available pixel formats.\n\n\n-sample_fmts\nShow available sample formats.\n\n\n-layouts\nShow channel names and standard channel layouts.\n\n\n-dispositions\nShow stream dispositions.\n\n\n-colors\nShow recognized color names.\n\n\n-sources device[,opt1=val1[,opt2=val2]...]\nShow autodetected sources of the input device.\nSome devices may provide system-dependent source names that cannot be autodetected.\nThe returned list cannot be assumed to be always complete.\n\nffmpeg -sources pulse,server=192.168.0.4\n\n\n-sinks device[,opt1=val1[,opt2=val2]...]\nShow autodetected sinks of the output device.\nSome devices may provide system-dependent sink names that cannot be autodetected.\nThe returned list cannot be assumed to be always complete.\n\nffmpeg -sinks pulse,server=192.168.0.4\n\n\n-loglevel [flags+]loglevel | -v [flags+]loglevel\nSet logging level and flags used by the library.\n\nThe optional flags prefix can consist of the following values:\n\n‘repeat’\nIndicates that repeated log output should not be compressed to the first line\nand the \"Last message repeated n times\" line will be omitted.\n\n‘level’\nIndicates that log output should add a [level] prefix to each message\nline. This can be used as an alternative to log coloring, e.g. when dumping the\nlog to file.\n\n\nFlags can also be used alone by adding a ’+’/’-’ prefix to set/reset a single\nflag without affecting other flags or changing loglevel. When\nsetting both flags and loglevel, a ’+’ separator is expected\nbetween the last flags value and before loglevel.\n\nloglevel is a string or a number containing one of the following values:\n\n‘quiet, -8’\nShow nothing at all; be silent.\n\n‘panic, 0’\nOnly show fatal errors which could lead the process to crash, such as\nan assertion failure. This is not currently used for anything.\n\n‘fatal, 8’\nOnly show fatal errors. These are errors after which the process absolutely\ncannot continue.\n\n‘error, 16’\nShow all errors, including ones which can be recovered from.\n\n‘warning, 24’\nShow all warnings and errors. Any message related to possibly\nincorrect or unexpected events will be shown.\n\n‘info, 32’\nShow informative messages during processing. This is in addition to\nwarnings and errors. This is the default value.\n\n‘verbose, 40’\nSame as info, except more verbose.\n\n‘debug, 48’\nShow everything, including debugging information.\n\n‘trace, 56’\n\nFor example to enable repeated log output, add the level prefix, and set\nloglevel to verbose:\n\nffmpeg -loglevel repeat+level+verbose -i input output\n\nAnother example that enables repeated log output without affecting current\nstate of level prefix flag or loglevel:\n\nffmpeg [...] -loglevel +repeat\n\nBy default the program logs to stderr. If coloring is supported by the\nterminal, colors are used to mark errors and warnings. Log coloring\ncan be disabled setting the environment variable\nAV_LOG_FORCE_NOCOLOR, or can be forced setting\nthe environment variable AV_LOG_FORCE_COLOR.\n\n\n-report\nDump full command line and log output to a file named\nprogram-YYYYMMDD-HHMMSS.log in the current\ndirectory.\nThis file can be useful for bug reports.\nIt also implies -loglevel debug.\n\nSetting the environment variable FFREPORT to any value has the\nsame effect. If the value is a ’:’-separated key=value sequence, these\noptions will affect the report; option values must be escaped if they\ncontain special characters or the options delimiter ’:’ (see the\n“Quoting and escaping” section in the ffmpeg-utils manual).\n\nThe following options are recognized:\n\nfile\nset the file name to use for the report; %p is expanded to the name\nof the program, %t is expanded to a timestamp, %% is expanded\nto a plain %\n\nlevel\nset the log verbosity level using a numerical value (see -loglevel).\n\n\nFor example, to output a report to a file named ffreport.log\nusing a log level of 32 (alias for log level info):\n\n\nFFREPORT=file=ffreport.log:level=32 ffmpeg -i input output\n\nErrors in parsing the environment variable are not fatal, and will not\nappear in the report.\n\n\n-hide_banner\nSuppress printing banner.\n\nAll FFmpeg tools will normally show a copyright notice, build options\nand library versions. This option can be used to suppress printing\nthis information.\n\n\n-cpuflags flags (global)\nAllows setting and clearing cpu flags. This option is intended\nfor testing. Do not use it unless you know what you’re doing.\n\nffmpeg -cpuflags -sse+mmx ...\nffmpeg -cpuflags mmx ...\nffmpeg -cpuflags 0 ...\n\nPossible flags for this option are:\n\n‘x86’\n\n‘mmx’\n‘mmxext’\n‘sse’\n‘sse2’\n‘sse2slow’\n‘sse3’\n‘sse3slow’\n‘ssse3’\n‘atom’\n‘sse4.1’\n‘sse4.2’\n‘avx’\n‘avx2’\n‘xop’\n‘fma3’\n‘fma4’\n‘3dnow’\n‘3dnowext’\n‘bmi1’\n‘bmi2’\n‘cmov’\n\n\n‘ARM’\n\n‘armv5te’\n‘armv6’\n‘armv6t2’\n‘vfp’\n‘vfpv3’\n‘neon’\n‘setend’\n\n\n‘AArch64’\n\n‘armv8’\n‘vfp’\n‘neon’\n\n\n‘PowerPC’\n\n‘altivec’\n\n\n‘Specific Processors’\n\n‘pentium2’\n‘pentium3’\n‘pentium4’\n‘k6’\n‘k62’\n‘athlon’\n‘athlonxp’\n‘k8’\n\n\n\n\n-cpucount count (global)\nOverride detection of CPU count. This option is intended\nfor testing. Do not use it unless you know what you’re doing.\n\nffmpeg -cpucount 2\n\n\n-max_alloc bytes\nSet the maximum size limit for allocating a block on the heap by ffmpeg’s\nfamily of malloc functions. Exercise extreme caution when using\nthis option. Don’t use if you do not understand the full consequence of doing so.\nDefault is INT_MAX.\n\n\n",
		"5.3 AVOptions": "5.3 AVOptions\nThese options are provided directly by the libavformat, libavdevice and\nlibavcodec libraries. To see the list of available AVOptions, use the\n-help option. They are separated into two categories:\n\n\ngeneric\nThese options can be set for any container, codec or device. Generic options\nare listed under AVFormatContext options for containers/devices and under\nAVCodecContext options for codecs.\n\nprivate\nThese options are specific to the given container, device or codec. Private\noptions are listed under their corresponding containers/devices/codecs.\n\n\nFor example to write an ID3v2.3 header instead of a default ID3v2.4 to\nan MP3 file, use the id3v2_version private option of the MP3\nmuxer:\n\n\nffmpeg -i input.flac -id3v2_version 3 out.mp3\n\nAll codec AVOptions are per-stream, and thus a stream specifier\nshould be attached to them:\n\n\nffmpeg -i multichannel.mxf -map 0:v:0 -map 0:a:0 -map 0:a:0 -c:a:0 ac3 -b:a:0 640k -ac:a:1 2 -c:a:1 aac -b:2 128k out.mp4\n\nIn the above example, a multichannel audio stream is mapped twice for output.\nThe first instance is encoded with codec ac3 and bitrate 640k.\nThe second instance is downmixed to 2 channels and encoded with codec aac. A bitrate of 128k is specified for it using\nabsolute index of the output stream.\n\nNote: the -nooption syntax cannot be used for boolean\nAVOptions, use -option 0/-option 1.\n\nNote: the old undocumented way of specifying per-stream AVOptions by\nprepending v/a/s to the options name is now obsolete and will be\nremoved soon.\n\n",
		"5.4 Main options": "5.4 Main options\n\n-f fmt (input/output)\nForce input or output file format. The format is normally auto detected for input\nfiles and guessed from the file extension for output files, so this option is not\nneeded in most cases.\n\n\n-i url (input)\ninput file url\n\n\n-y (global)\nOverwrite output files without asking.\n\n\n-n (global)\nDo not overwrite output files, and exit immediately if a specified\noutput file already exists.\n\n\n-stream_loop number (input)\nSet number of times input stream shall be looped. Loop 0 means no loop,\nloop -1 means infinite loop.\n\n\n-recast_media (global)\nAllow forcing a decoder of a different media type than the one\ndetected or designated by the demuxer. Useful for decoding media\ndata muxed as data streams.\n\n\n-c[:stream_specifier] codec (input/output,per-stream)\n-codec[:stream_specifier] codec (input/output,per-stream)\nSelect an encoder (when used before an output file) or a decoder (when used\nbefore an input file) for one or more streams. codec is the name of a\ndecoder/encoder or a special value copy (output only) to indicate that\nthe stream is not to be re-encoded.\n\nFor example\n\nffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT\n\nencodes all video streams with libx264 and copies all audio streams.\n\nFor each stream, the last matching c option is applied, so\n\nffmpeg -i INPUT -map 0 -c copy -c:v:1 libx264 -c:a:137 libvorbis OUTPUT\n\nwill copy all the streams except the second video, which will be encoded with\nlibx264, and the 138th audio, which will be encoded with libvorbis.\n\n\n-t duration (input/output)\nWhen used as an input option (before -i), limit the duration of\ndata read from the input file.\n\nWhen used as an output option (before an output url), stop writing the\noutput after its duration reaches duration.\n\nduration must be a time duration specification,\nsee (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual.\n\n-to and -t are mutually exclusive and -t has priority.\n\n\n-to position (input/output)\nStop writing the output or reading the input at position.\nposition must be a time duration specification,\nsee (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual.\n\n-to and -t are mutually exclusive and -t has priority.\n\n\n-fs limit_size (output)\nSet the file size limit, expressed in bytes. No further chunk of bytes is written\nafter the limit is exceeded. The size of the output file is slightly more than the\nrequested file size.\n\n\n-ss position (input/output)\nWhen used as an input option (before -i), seeks in this input file to\nposition. Note that in most formats it is not possible to seek exactly,\nso ffmpeg will seek to the closest seek point before position.\nWhen transcoding and -accurate_seek is enabled (the default), this\nextra segment between the seek point and position will be decoded and\ndiscarded. When doing stream copy or when -noaccurate_seek is used, it\nwill be preserved.\n\nWhen used as an output option (before an output url), decodes but discards\ninput until the timestamps reach position.\n\nposition must be a time duration specification,\nsee (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual.\n\n\n-sseof position (input)\n\nLike the -ss option but relative to the \"end of file\". That is negative\nvalues are earlier in the file, 0 is at EOF.\n\n\n-isync input_index (input)\nAssign an input as a sync source.\n\nThis will take the difference between the start times of the target and reference inputs and\noffset the timestamps of the target file by that difference. The source timestamps of the two\ninputs should derive from the same clock source for expected results. If copyts is set\nthen start_at_zero must also be set. If either of the inputs has no starting timestamp\nthen no sync adjustment is made.\n\nAcceptable values are those that refer to a valid ffmpeg input index. If the sync reference is\nthe target index itself or -1, then no adjustment is made to target timestamps. A sync\nreference may not itself be synced to any other input.\n\nDefault value is -1.\n\n\n-itsoffset offset (input)\nSet the input time offset.\n\noffset must be a time duration specification,\nsee (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual.\n\nThe offset is added to the timestamps of the input files. Specifying\na positive offset means that the corresponding streams are delayed by\nthe time duration specified in offset.\n\n\n-itsscale scale (input,per-stream)\nRescale input timestamps. scale should be a floating point number.\n\n\n-timestamp date (output)\nSet the recording timestamp in the container.\n\ndate must be a date specification,\nsee (ffmpeg-utils)the Date section in the ffmpeg-utils(1) manual.\n\n\n-metadata[:metadata_specifier] key=value (output,per-metadata)\nSet a metadata key/value pair.\n\nAn optional metadata_specifier may be given to set metadata\non streams, chapters or programs. See -map_metadata\ndocumentation for details.\n\nThis option overrides metadata set with -map_metadata. It is\nalso possible to delete metadata by using an empty value.\n\nFor example, for setting the title in the output file:\n\nffmpeg -i in.avi -metadata title=\"my title\" out.flv\n\nTo set the language of the first audio stream:\n\nffmpeg -i INPUT -metadata:s:a:0 language=eng OUTPUT\n\n\n-disposition[:stream_specifier] value (output,per-stream)\nSets the disposition for a stream.\n\nBy default, the disposition is copied from the input stream, unless the output\nstream this option applies to is fed by a complex filtergraph - in that case the\ndisposition is unset by default.\n\nvalue is a sequence of items separated by ’+’ or ’-’. The first item may\nalso be prefixed with ’+’ or ’-’, in which case this option modifies the default\nvalue. Otherwise (the first item is not prefixed) this options overrides the\ndefault value. A ’+’ prefix adds the given disposition, ’-’ removes it. It is\nalso possible to clear the disposition by setting it to 0.\n\nIf no -disposition options were specified for an output file, ffmpeg will\nautomatically set the ’default’ disposition on the first stream of each type,\nwhen there are multiple streams of this type in the output file and no stream of\nthat type is already marked as default.\n\nThe -dispositions option lists the known dispositions.\n\nFor example, to make the second audio stream the default stream:\n\nffmpeg -i in.mkv -c copy -disposition:a:1 default out.mkv\n\nTo make the second subtitle stream the default stream and remove the default\ndisposition from the first subtitle stream:\n\nffmpeg -i in.mkv -c copy -disposition:s:0 0 -disposition:s:1 default out.mkv\n\nTo add an embedded cover/thumbnail:\n\nffmpeg -i in.mp4 -i IMAGE -map 0 -map 1 -c copy -c:v:1 png -disposition:v:1 attached_pic out.mp4\n\nNot all muxers support embedded thumbnails, and those who do, only support a few formats, like JPEG or PNG.\n\n\n-program [title=title:][program_num=program_num:]st=stream[:st=stream...] (output)\n\nCreates a program with the specified title, program_num and adds the specified\nstream(s) to it.\n\n\n-stream_group [map=input_file_id=stream_group][type=type:]st=stream[:st=stream][:stg=stream_group][:id=stream_group_id...] (output)\n\nCreates a stream group of the specified type and stream_group_id, or by\nmapping an input group, adding the specified stream(s) and/or previously\ndefined stream_group(s) to it.\n\ntype can be one of the following:\n\niamf_audio_element\nGroups streams that belong to the same IAMF Audio Element\n\nFor this group type, the following options are available\n\naudio_element_type\nThe Audio Element type. The following values are supported:\n\n\nchannel\nScalable channel audio representation\n\nscene\nAmbisonics representation\n\n\n\ndemixing\nDemixing information used to reconstruct a scalable channel audio representation.\nThis option must be separated from the rest with a ’,’, and takes the following\nkey=value options\n\n\nparameter_id\nAn identifier parameters blocks in frames may refer to\n\ndmixp_mode\nA pre-defined combination of demixing parameters\n\n\n\nrecon_gain\nRecon gain information used to reconstruct a scalable channel audio representation.\nThis option must be separated from the rest with a ’,’, and takes the following\nkey=value options\n\n\nparameter_id\nAn identifier parameters blocks in frames may refer to\n\n\n\nlayer\nA layer defining a Channel Layout in the Audio Element.\nThis option must be separated from the rest with a ’,’. Several ’,’ separated entries\ncan be defined, and at least one must be set.\n\nIt takes the following \":\"-separated key=value options\n\n\nch_layout\nThe layer’s channel layout\n\nflags\nThe following flags are available:\n\n\nrecon_gain\nWether to signal if recon_gain is present as metadata in parameter blocks within frames\n\n\n\noutput_gain\noutput_gain_flags\nWhich channels output_gain applies to. The following flags are available:\n\n\nFL\nFR\nBL\nBR\nTFL\nTFR\n\n\nambisonics_mode\nThe ambisonics mode. This has no effect if audio_element_type is set to channel.\n\nThe following values are supported:\n\n\nmono\nEach ambisonics channel is coded as an individual mono stream in the group\n\n\n\n\n\ndefault_w\nDefault weight value\n\n\n\n\niamf_mix_presentation\nGroups streams that belong to all IAMF Audio Element the same\nIAMF Mix Presentation references\n\nFor this group type, the following options are available\n\n\nsubmix\nA sub-mix within the Mix Presentation.\nThis option must be separated from the rest with a ’,’. Several ’,’ separated entries\ncan be defined, and at least one must be set.\n\nIt takes the following \":\"-separated key=value options\n\n\nparameter_id\nAn identifier parameters blocks in frames may refer to, for post-processing the mixed\naudio signal to generate the audio signal for playback\n\nparameter_rate\nThe sample rate duration fields in parameters blocks in frames that refer to this\nparameter_id are expressed as\n\ndefault_mix_gain\nDefault mix gain value to apply when there are no parameter blocks sharing the same\nparameter_id for a given frame\n\n\nelement\nReferences an Audio Element used in this Mix Presentation to generate the final output\naudio signal for playback.\nThis option must be separated from the rest with a ’|’. Several ’|’ separated entries\ncan be defined, and at least one must be set.\n\nIt takes the following \":\"-separated key=value options:\n\n\nstg\nThe stream_group_id for an Audio Element which this sub-mix refers to\n\nparameter_id\nAn identifier parameters blocks in frames may refer to, for applying any processing to\nthe referenced and rendered Audio Element before being summed with other processed Audio\nElements\n\nparameter_rate\nThe sample rate duration fields in parameters blocks in frames that refer to this\nparameter_id are expressed as\n\ndefault_mix_gain\nDefault mix gain value to apply when there are no parameter blocks sharing the same\nparameter_id for a given frame\n\nannotations\nA key=value string describing the sub-mix element where \"key\" is a string conforming to\nBCP-47 that specifies the language for the \"value\" string. \"key\" must be the same as the\none in the mix’s annotations\n\nheadphones_rendering_mode\nIndicates whether the input channel-based Audio Element is rendered to stereo loudspeakers\nor spatialized with a binaural renderer when played back on headphones.\nThis has no effect if the referenced Audio Element’s audio_element_type is set to\nchannel.\n\nThe following values are supported:\n\n\nstereo\nbinaural\n\n\n\n\nlayout\nSpecifies the layouts for this sub-mix on which the loudness information was measured.\nThis option must be separated from the rest with a ’|’. Several ’|’ separated entries\ncan be defined, and at least one must be set.\n\nIt takes the following \":\"-separated key=value options:\n\n\nlayout_type\n\n\nloudspeakers\nThe layout follows the loudspeaker sound system convention of ITU-2051-3.\n\nbinaural\nThe layout is binaural.\n\n\n\nsound_system\nChannel layout matching one of Sound Systems A to J of ITU-2051-3, plus 7.1.2 and 3.1.2\nThis has no effect if layout_type is set to binaural.\n\nintegrated_loudness\nThe program integrated loudness information, as defined in ITU-1770-4.\n\ndigital_peak\nThe digital (sampled) peak value of the audio signal, as defined in ITU-1770-4.\n\ntrue_peak\nThe true peak of the audio signal, as defined in ITU-1770-4.\n\ndialog_anchored_loudness\nThe Dialogue loudness information, as defined in ITU-1770-4.\n\nalbum_anchored_loudness\nThe Album loudness information, as defined in ITU-1770-4.\n\n\n\n\n\nannotations\nA key=value string string describing the mix where \"key\" is a string conforming to BCP-47\nthat specifies the language for the \"value\" string. \"key\" must be the same as the ones in\nall sub-mix element’s annotationss\n\n\n\n\nE.g. to create an scalable 5.1 IAMF file from several WAV input files\n\nffmpeg -i front.wav -i back.wav -i center.wav -i lfe.wav\n-map 0:0 -map 1:0 -map 2:0 -map 3:0 -c:a opus\n-stream_group type=iamf_audio_element:id=1:st=0:st=1:st=2:st=3,\ndemixing=parameter_id=998,\nrecon_gain=parameter_id=101,\nlayer=ch_layout=stereo,\nlayer=ch_layout=5.1,\n-stream_group type=iamf_mix_presentation:id=2:stg=0:annotations=en-us=Mix_Presentation,\nsubmix=parameter_id=100:parameter_rate=48000|element=stg=0:parameter_id=100:annotations=en-us=Scalable_Submix|layout=sound_system=stereo|layout=sound_system=5.1\n-streamid 0:0 -streamid 1:1 -streamid 2:2 -streamid 3:3 output.iamf\n\nTo copy the two stream groups (Audio Element and Mix Presentation) from an input IAMF file with four\nstreams into an mp4 output\n\nffmpeg -i input.iamf -c:a copy -stream_group map=0=0:st=0:st=1:st=2:st=3 -stream_group map=0=1:stg=0\n-streamid 0:0 -streamid 1:1 -streamid 2:2 -streamid 3:3 output.mp4\n\n\n-target type (output)\nSpecify target file type (vcd, svcd, dvd, dv,\ndv50). type may be prefixed with pal-, ntsc- or\nfilm- to use the corresponding standard. All the format options\n(bitrate, codecs, buffer sizes) are then set automatically. You can just type:\n\n\nffmpeg -i myfile.avi -target vcd /tmp/vcd.mpg\n\nNevertheless you can specify additional options as long as you know\nthey do not conflict with the standard, as in:\n\n\nffmpeg -i myfile.avi -target vcd -bf 2 /tmp/vcd.mpg\n\nThe parameters set for each target are as follows.\n\nVCD\n\npal:\n-f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324\n-s 352x288 -r 25\n-codec:v mpeg1video -g 15 -b:v 1150k -maxrate:v 1150k -minrate:v 1150k -bufsize:v 327680\n-ar 44100 -ac 2\n-codec:a mp2 -b:a 224k\n\nntsc:\n-f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324\n-s 352x240 -r 30000/1001\n-codec:v mpeg1video -g 18 -b:v 1150k -maxrate:v 1150k -minrate:v 1150k -bufsize:v 327680\n-ar 44100 -ac 2\n-codec:a mp2 -b:a 224k\n\nfilm:\n-f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324\n-s 352x240 -r 24000/1001\n-codec:v mpeg1video -g 18 -b:v 1150k -maxrate:v 1150k -minrate:v 1150k -bufsize:v 327680\n-ar 44100 -ac 2\n-codec:a mp2 -b:a 224k\n\nSVCD\n\npal:\n-f svcd -packetsize 2324\n-s 480x576 -pix_fmt yuv420p -r 25\n-codec:v mpeg2video -g 15 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1\n-ar 44100\n-codec:a mp2 -b:a 224k\n\nntsc:\n-f svcd -packetsize 2324\n-s 480x480 -pix_fmt yuv420p -r 30000/1001\n-codec:v mpeg2video -g 18 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1\n-ar 44100\n-codec:a mp2 -b:a 224k\n\nfilm:\n-f svcd -packetsize 2324\n-s 480x480 -pix_fmt yuv420p -r 24000/1001\n-codec:v mpeg2video -g 18 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1\n-ar 44100\n-codec:a mp2 -b:a 224k\n\nDVD\n\npal:\n-f dvd -muxrate 10080k -packetsize 2048\n-s 720x576 -pix_fmt yuv420p -r 25\n-codec:v mpeg2video -g 15 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008\n-ar 48000\n-codec:a ac3 -b:a 448k\n\nntsc:\n-f dvd -muxrate 10080k -packetsize 2048\n-s 720x480 -pix_fmt yuv420p -r 30000/1001\n-codec:v mpeg2video -g 18 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008\n-ar 48000\n-codec:a ac3 -b:a 448k\n\nfilm:\n-f dvd -muxrate 10080k -packetsize 2048\n-s 720x480 -pix_fmt yuv420p -r 24000/1001\n-codec:v mpeg2video -g 18 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008\n-ar 48000\n-codec:a ac3 -b:a 448k\n\nDV\n\npal:\n-f dv\n-s 720x576 -pix_fmt yuv420p -r 25\n-ar 48000 -ac 2\n\nntsc:\n-f dv\n-s 720x480 -pix_fmt yuv411p -r 30000/1001\n-ar 48000 -ac 2\n\nfilm:\n-f dv\n-s 720x480 -pix_fmt yuv411p -r 24000/1001\n-ar 48000 -ac 2\n\nThe dv50 target is identical to the dv target except that the pixel format set is yuv422p for all three standards.\n\nAny user-set value for a parameter above will override the target preset value. In that case, the output may\nnot comply with the target standard.\n\n\n-dn (input/output)\nAs an input option, blocks all data streams of a file from being filtered or\nbeing automatically selected or mapped for any output. See -discard\noption to disable streams individually.\n\nAs an output option, disables data recording i.e. automatic selection or\nmapping of any data stream. For full manual control see the -map\noption.\n\n\n-dframes number (output)\nSet the number of data frames to output. This is an obsolete alias for\n-frames:d, which you should use instead.\n\n\n-frames[:stream_specifier] framecount (output,per-stream)\nStop writing to the stream after framecount frames.\n\n\n-q[:stream_specifier] q (output,per-stream)\n-qscale[:stream_specifier] q (output,per-stream)\nUse fixed quality scale (VBR). The meaning of q/qscale is\ncodec-dependent.\nIf qscale is used without a stream_specifier then it applies only\nto the video stream, this is to maintain compatibility with previous behavior\nand as specifying the same codec specific value to 2 different codecs that is\naudio and video generally is not what is intended when no stream_specifier is\nused.\n\n\n-filter[:stream_specifier] filtergraph (output,per-stream)\nCreate the filtergraph specified by filtergraph and use it to\nfilter the stream.\n\nfiltergraph is a description of the filtergraph to apply to\nthe stream, and must have a single input and a single output of the\nsame type of the stream. In the filtergraph, the input is associated\nto the label in, and the output to the label out. See\nthe ffmpeg-filters manual for more information about the filtergraph\nsyntax.\n\nSee the -filter_complex option if you\nwant to create filtergraphs with multiple inputs and/or outputs.\n\n\n-reinit_filter[:stream_specifier] integer (input,per-stream)\nThis boolean option determines if the filtergraph(s) to which this stream is fed gets\nreinitialized when input frame parameters change mid-stream. This option is enabled by\ndefault as most video and all audio filters cannot handle deviation in input frame properties.\nUpon reinitialization, existing filter state is lost, like e.g. the frame count n\nreference available in some filters. Any frames buffered at time of reinitialization are lost.\nThe properties where a change triggers reinitialization are,\nfor video, frame resolution or pixel format;\nfor audio, sample format, sample rate, channel count or channel layout.\n\n\n-filter_threads nb_threads (global)\nDefines how many threads are used to process a filter pipeline. Each pipeline\nwill produce a thread pool with this many threads available for parallel processing.\nThe default is the number of available CPUs.\n\n\n-pre[:stream_specifier] preset_name (output,per-stream)\nSpecify the preset for matching stream(s).\n\n\n-stats (global)\nPrint encoding progress/statistics. It is on by default, to explicitly\ndisable it you need to specify -nostats.\n\n\n-stats_period time (global)\nSet period at which encoding progress/statistics are updated. Default is 0.5 seconds.\n\n\n-progress url (global)\nSend program-friendly progress information to url.\n\nProgress information is written periodically and at the end of\nthe encoding process. It is made of \"key=value\" lines. key\nconsists of only alphanumeric characters. The last key of a sequence of\nprogress information is always \"progress\".\n\nThe update period is set using -stats_period.\n\n\n-stdin\nEnable interaction on standard input. On by default unless standard input is\nused as an input. To explicitly disable interaction you need to specify\n-nostdin.\n\nDisabling interaction on standard input is useful, for example, if\nffmpeg is in the background process group. Roughly the same result can\nbe achieved with ffmpeg ... < /dev/null but it requires a\nshell.\n\n\n-debug_ts (global)\nPrint timestamp/latency information. It is off by default. This option is\nmostly useful for testing and debugging purposes, and the output\nformat may change from one version to another, so it should not be\nemployed by portable scripts.\n\nSee also the option -fdebug ts.\n\n\n-attach filename (output)\nAdd an attachment to the output file. This is supported by a few formats\nlike Matroska for e.g. fonts used in rendering subtitles. Attachments\nare implemented as a specific type of stream, so this option will add\na new stream to the file. It is then possible to use per-stream options\non this stream in the usual way. Attachment streams created with this\noption will be created after all the other streams (i.e. those created\nwith -map or automatic mappings).\n\nNote that for Matroska you also have to set the mimetype metadata tag:\n\nffmpeg -i INPUT -attach DejaVuSans.ttf -metadata:s:2 mimetype=application/x-truetype-font out.mkv\n\n(assuming that the attachment stream will be third in the output file).\n\n\n-dump_attachment[:stream_specifier] filename (input,per-stream)\nExtract the matching attachment stream into a file named filename. If\nfilename is empty, then the value of the filename metadata tag\nwill be used.\n\nE.g. to extract the first attachment to a file named ’out.ttf’:\n\nffmpeg -dump_attachment:t:0 out.ttf -i INPUT\n\nTo extract all attachments to files determined by the filename tag:\n\nffmpeg -dump_attachment:t \"\" -i INPUT\n\nTechnical note – attachments are implemented as codec extradata, so this\noption can actually be used to extract extradata from any stream, not just\nattachments.\n\n\n",
		"5.5 Video Options": "5.5 Video Options\n\n-vframes number (output)\nSet the number of video frames to output. This is an obsolete alias for\n-frames:v, which you should use instead.\n\n-r[:stream_specifier] fps (input/output,per-stream)\nSet frame rate (Hz value, fraction or abbreviation).\n\nAs an input option, ignore any timestamps stored in the file and instead\ngenerate timestamps assuming constant frame rate fps.\nThis is not the same as the -framerate option used for some input formats\nlike image2 or v4l2 (it used to be the same in older versions of FFmpeg).\nIf in doubt use -framerate instead of the input option -r.\n\nAs an output option:\n\nvideo encoding\nDuplicate or drop frames right before encoding them to achieve constant output\nframe rate fps.\n\n\nvideo streamcopy\nIndicate to the muxer that fps is the stream frame rate. No data is\ndropped or duplicated in this case. This may produce invalid files if fps\ndoes not match the actual stream frame rate as determined by packet timestamps.\nSee also the setts bitstream filter.\n\n\n\n\n-fpsmax[:stream_specifier] fps (output,per-stream)\nSet maximum frame rate (Hz value, fraction or abbreviation).\n\nClamps output frame rate when output framerate is auto-set and is higher than this value.\nUseful in batch processing or when input framerate is wrongly detected as very high.\nIt cannot be set together with -r. It is ignored during streamcopy.\n\n\n-s[:stream_specifier] size (input/output,per-stream)\nSet frame size.\n\nAs an input option, this is a shortcut for the video_size private\noption, recognized by some demuxers for which the frame size is either not\nstored in the file or is configurable – e.g. raw video or video grabbers.\n\nAs an output option, this inserts the scale video filter to the\nend of the corresponding filtergraph. Please use the scale filter\ndirectly to insert it at the beginning or some other place.\n\nThe format is ‘wxh’ (default - same as source).\n\n\n-aspect[:stream_specifier] aspect (output,per-stream)\nSet the video display aspect ratio specified by aspect.\n\naspect can be a floating point number string, or a string of the\nform num:den, where num and den are the\nnumerator and denominator of the aspect ratio. For example \"4:3\",\n\"16:9\", \"1.3333\", and \"1.7777\" are valid argument values.\n\nIf used together with -vcodec copy, it will affect the aspect ratio\nstored at container level, but not the aspect ratio stored in encoded\nframes, if it exists.\n\n\n-display_rotation[:stream_specifier] rotation (input,per-stream)\nSet video rotation metadata.\n\nrotation is a decimal number specifying the amount in degree by\nwhich the video should be rotated counter-clockwise before being\ndisplayed.\n\nThis option overrides the rotation/display transform metadata stored in\nthe file, if any. When the video is being transcoded (rather than\ncopied) and -autorotate is enabled, the video will be rotated at\nthe filtering stage. Otherwise, the metadata will be written into the\noutput file if the muxer supports it.\n\nIf the -display_hflip and/or -display_vflip options are\ngiven, they are applied after the rotation specified by this option.\n\n\n-display_hflip[:stream_specifier] (input,per-stream)\nSet whether on display the image should be horizontally flipped.\n\nSee the -display_rotation option for more details.\n\n\n-display_vflip[:stream_specifier] (input,per-stream)\nSet whether on display the image should be vertically flipped.\n\nSee the -display_rotation option for more details.\n\n\n-vn (input/output)\nAs an input option, blocks all video streams of a file from being filtered or\nbeing automatically selected or mapped for any output. See -discard\noption to disable streams individually.\n\nAs an output option, disables video recording i.e. automatic selection or\nmapping of any video stream. For full manual control see the -map\noption.\n\n\n-vcodec codec (output)\nSet the video codec. This is an alias for -codec:v.\n\n\n-pass[:stream_specifier] n (output,per-stream)\nSelect the pass number (1 or 2). It is used to do two-pass\nvideo encoding. The statistics of the video are recorded in the first\npass into a log file (see also the option -passlogfile),\nand in the second pass that log file is used to generate the video\nat the exact requested bitrate.\nOn pass 1, you may just deactivate audio and set output to null,\nexamples for Windows and Unix:\n\nffmpeg -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y NUL\nffmpeg -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y /dev/null\n\n\n-passlogfile[:stream_specifier] prefix (output,per-stream)\nSet two-pass log file name prefix to prefix, the default file name\nprefix is “ffmpeg2pass”. The complete file name will be\nPREFIX-N.log, where N is a number specific to the output\nstream\n\n\n-vf filtergraph (output)\nCreate the filtergraph specified by filtergraph and use it to\nfilter the stream.\n\nThis is an alias for -filter:v, see the -filter option.\n\n\n-autorotate\nAutomatically rotate the video according to file metadata. Enabled by\ndefault, use -noautorotate to disable it.\n\n\n-autoscale\nAutomatically scale the video according to the resolution of first frame.\nEnabled by default, use -noautoscale to disable it. When autoscale is\ndisabled, all output frames of filter graph might not be in the same resolution\nand may be inadequate for some encoder/muxer. Therefore, it is not recommended\nto disable it unless you really know what you are doing.\nDisable autoscale at your own risk.\n\n\n",
		"5.6 Advanced Video options": "5.6 Advanced Video options\n\n-pix_fmt[:stream_specifier] format (input/output,per-stream)\nSet pixel format. Use -pix_fmts to show all the supported\npixel formats.\nIf the selected pixel format can not be selected, ffmpeg will print a\nwarning and select the best pixel format supported by the encoder.\nIf pix_fmt is prefixed by a +, ffmpeg will exit with an error\nif the requested pixel format can not be selected, and automatic conversions\ninside filtergraphs are disabled.\nIf pix_fmt is a single +, ffmpeg selects the same pixel format\nas the input (or graph output) and automatic conversions are disabled.\n\n\n-sws_flags flags (input/output)\nSet default flags for the libswscale library. These flags are used by\nautomatically inserted scale filters and those within simple\nfiltergraphs, if not overridden within the filtergraph definition.\n\nSee the (ffmpeg-scaler)ffmpeg-scaler manual for a list\nof scaler options.\n\n\n-rc_override[:stream_specifier] override (output,per-stream)\nRate control override for specific intervals, formatted as \"int,int,int\"\nlist separated with slashes. Two first values are the beginning and\nend frame numbers, last one is quantizer to use if positive, or quality\nfactor if negative.\n\n\n-vstats\nDump video coding statistics to vstats_HHMMSS.log. See the\nvstats file format section for the format description.\n\n\n-vstats_file file\nDump video coding statistics to file. See the\nvstats file format section for the format description.\n\n\n-vstats_version file\nSpecify which version of the vstats format to use. Default is 2. See the\nvstats file format section for the format description.\n\n\n-vtag fourcc/tag (output)\nForce video tag/fourcc. This is an alias for -tag:v.\n\n\n-force_key_frames[:stream_specifier] time[,time...] (output,per-stream)\n-force_key_frames[:stream_specifier] expr:expr (output,per-stream)\n-force_key_frames[:stream_specifier] source (output,per-stream)\n\nforce_key_frames can take arguments of the following form:\n\n\ntime[,time...]\nIf the argument consists of timestamps, ffmpeg will round the specified times to the nearest\noutput timestamp as per the encoder time base and force a keyframe at the first frame having\ntimestamp equal or greater than the computed timestamp. Note that if the encoder time base is too\ncoarse, then the keyframes may be forced on frames with timestamps lower than the specified time.\nThe default encoder time base is the inverse of the output framerate but may be set otherwise\nvia -enc_time_base.\n\nIf one of the times is \"chapters[delta]\", it is expanded into\nthe time of the beginning of all chapters in the file, shifted by\ndelta, expressed as a time in seconds.\nThis option can be useful to ensure that a seek point is present at a\nchapter mark or any other designated place in the output file.\n\nFor example, to insert a key frame at 5 minutes, plus key frames 0.1 second\nbefore the beginning of every chapter:\n\n-force_key_frames 0:05:00,chapters-0.1\n\n\nexpr:expr\nIf the argument is prefixed with expr:, the string expr\nis interpreted like an expression and is evaluated for each frame. A\nkey frame is forced in case the evaluation is non-zero.\n\nThe expression in expr can contain the following constants:\n\nn\nthe number of current processed frame, starting from 0\n\nn_forced\nthe number of forced frames\n\nprev_forced_n\nthe number of the previous forced frame, it is NAN when no\nkeyframe was forced yet\n\nprev_forced_t\nthe time of the previous forced frame, it is NAN when no\nkeyframe was forced yet\n\nt\nthe time of the current processed frame\n\n\nFor example to force a key frame every 5 seconds, you can specify:\n\n-force_key_frames expr:gte(t,n_forced*5)\n\nTo force a key frame 5 seconds after the time of the last forced one,\nstarting from second 13:\n\n-force_key_frames expr:if(isnan(prev_forced_t),gte(t,13),gte(t,prev_forced_t+5))\n\n\nsource\nIf the argument is source, ffmpeg will force a key frame if\nthe current frame being encoded is marked as a key frame in its source.\nIn cases where this particular source frame has to be dropped,\nenforce the next available frame to become a key frame instead.\n\n\n\nNote that forcing too many keyframes is very harmful for the lookahead\nalgorithms of certain encoders: using fixed-GOP options or similar\nwould be more efficient.\n\n\n-copyinkf[:stream_specifier] (output,per-stream)\nWhen doing stream copy, copy also non-key frames found at the\nbeginning.\n\n\n-init_hw_device type[=name][:device[,key=value...]]\nInitialise a new hardware device of type type called name, using the\ngiven device parameters.\nIf no name is specified it will receive a default name of the form \"type%d\".\n\nThe meaning of device and the following arguments depends on the\ndevice type:\n\ncuda\ndevice is the number of the CUDA device.\n\nThe following options are recognized:\n\nprimary_ctx\nIf set to 1, uses the primary device context instead of creating a new one.\n\n\nExamples:\n\n-init_hw_device cuda:1\nChoose the second device on the system.\n\n\n-init_hw_device cuda:0,primary_ctx=1\nChoose the first device and use the primary device context.\n\n\n\ndxva2\ndevice is the number of the Direct3D 9 display adapter.\n\n\nd3d11va\ndevice is the number of the Direct3D 11 display adapter.\nIf not specified, it will attempt to use the default Direct3D 11 display adapter\nor the first Direct3D 11 display adapter whose hardware VendorId is specified\nby ‘vendor_id’.\n\nExamples:\n\n-init_hw_device d3d11va\nCreate a d3d11va device on the default Direct3D 11 display adapter.\n\n\n-init_hw_device d3d11va:1\nCreate a d3d11va device on the Direct3D 11 display adapter specified by index 1.\n\n\n-init_hw_device d3d11va:,vendor_id=0x8086\nCreate a d3d11va device on the first Direct3D 11 display adapter whose hardware VendorId is 0x8086.\n\n\n\nvaapi\ndevice is either an X11 display name, a DRM render node or a DirectX adapter index.\nIf not specified, it will attempt to open the default X11 display ($DISPLAY)\nand then the first DRM render node (/dev/dri/renderD128), or the default\nDirectX adapter on Windows.\n\nThe following options are recognized:\n\nkernel_driver\nWhen device is not specified, use this option to specify the name of the kernel\ndriver associated with the desired device. This option is available only when\nthe hardware acceleration method drm and vaapi are enabled.\n\n\nExamples:\n\n-init_hw_device vaapi\nCreate a vaapi device on the default device.\n\n\n-init_hw_device vaapi:/dev/dri/renderD129\nCreate a vaapi device on DRM render node /dev/dri/renderD129.\n\n\n-init_hw_device vaapi:1\nCreate a vaapi device on DirectX adapter 1.\n\n\n-init_hw_device vaapi:,kernel_driver=i915\nCreate a vaapi device on a device associated with kernel driver ‘i915’.\n\n\n\nvdpau\ndevice is an X11 display name.\nIf not specified, it will attempt to open the default X11 display ($DISPLAY).\n\n\nqsv\ndevice selects a value in ‘MFX_IMPL_*’. Allowed values are:\n\nauto\nsw\nhw\nauto_any\nhw_any\nhw2\nhw3\nhw4\n\nIf not specified, ‘auto_any’ is used.\n(Note that it may be easier to achieve the desired result for QSV by creating the\nplatform-appropriate subdevice (‘dxva2’ or ‘d3d11va’ or ‘vaapi’) and then deriving a\nQSV device from that.)\n\nThe following options are recognized:\n\nchild_device\nSpecify a DRM render node on Linux or DirectX adapter on Windows.\n\nchild_device_type\nChoose platform-appropriate subdevice type. On Windows ‘d3d11va’ is used\nas default subdevice type when --enable-libvpl is specified at configuration time,\n‘dxva2’ is used as default subdevice type when --enable-libmfx is specified at\nconfiguration time. On Linux user can use ‘vaapi’ only as subdevice type.\n\n\nExamples:\n\n-init_hw_device qsv:hw,child_device=/dev/dri/renderD129\nCreate a QSV device with ‘MFX_IMPL_HARDWARE’ on DRM render node /dev/dri/renderD129.\n\n\n-init_hw_device qsv:hw,child_device=1\nCreate a QSV device with ‘MFX_IMPL_HARDWARE’ on DirectX adapter 1.\n\n\n-init_hw_device qsv:hw,child_device_type=d3d11va\nChoose the GPU subdevice with type ‘d3d11va’ and create QSV device with ‘MFX_IMPL_HARDWARE’.\n\n\n-init_hw_device qsv:hw,child_device_type=dxva2\nChoose the GPU subdevice with type ‘dxva2’ and create QSV device with ‘MFX_IMPL_HARDWARE’.\n\n\n-init_hw_device qsv:hw,child_device=1,child_device_type=d3d11va\nCreate a QSV device with ‘MFX_IMPL_HARDWARE’ on DirectX adapter 1 with subdevice type ‘d3d11va’.\n\n\n-init_hw_device vaapi=va:/dev/dri/renderD129 -init_hw_device qsv=hw1@va\nCreate a VAAPI device called ‘va’ on /dev/dri/renderD129, then derive a QSV device called ‘hw1’\nfrom device ‘va’.\n\n\n\n\nopencl\ndevice selects the platform and device as platform_index.device_index.\n\nThe set of devices can also be filtered using the key-value pairs to find only\ndevices matching particular platform or device strings.\n\nThe strings usable as filters are:\n\nplatform_profile\nplatform_version\nplatform_name\nplatform_vendor\nplatform_extensions\ndevice_name\ndevice_vendor\ndriver_version\ndevice_version\ndevice_profile\ndevice_extensions\ndevice_type\n\nThe indices and filters must together uniquely select a device.\n\nExamples:\n\n-init_hw_device opencl:0.1\nChoose the second device on the first platform.\n\n\n-init_hw_device opencl:,device_name=Foo9000\nChoose the device with a name containing the string Foo9000.\n\n\n-init_hw_device opencl:1,device_type=gpu,device_extensions=cl_khr_fp16\nChoose the GPU device on the second platform supporting the cl_khr_fp16\nextension.\n\n\n\nvulkan\nIf device is an integer, it selects the device by its index in a\nsystem-dependent list of devices.  If device is any other string, it\nselects the first device with a name containing that string as a substring.\n\nThe following options are recognized:\n\ndebug\nIf set to 1, enables the validation layer, if installed.\n\nlinear_images\nIf set to 1, images allocated by the hwcontext will be linear and locally mappable.\n\ninstance_extensions\nA plus separated list of additional instance extensions to enable.\n\ndevice_extensions\nA plus separated list of additional device extensions to enable.\n\n\nExamples:\n\n-init_hw_device vulkan:1\nChoose the second device on the system.\n\n\n-init_hw_device vulkan:RADV\nChoose the first device with a name containing the string RADV.\n\n\n-init_hw_device vulkan:0,instance_extensions=VK_KHR_wayland_surface+VK_KHR_xcb_surface\nChoose the first device and enable the Wayland and XCB instance extensions.\n\n\n\n\n\n-init_hw_device type[=name]@source\nInitialise a new hardware device of type type called name,\nderiving it from the existing device with the name source.\n\n\n-init_hw_device list\nList all hardware device types supported in this build of ffmpeg.\n\n\n-filter_hw_device name\nPass the hardware device called name to all filters in any filter graph.\nThis can be used to set the device to upload to with the hwupload filter,\nor the device to map to with the hwmap filter.  Other filters may also\nmake use of this parameter when they require a hardware device.  Note that this\nis typically only required when the input is not already in hardware frames -\nwhen it is, filters will derive the device they require from the context of the\nframes they receive as input.\n\nThis is a global setting, so all filters will receive the same device.\n\n\n-hwaccel[:stream_specifier] hwaccel (input,per-stream)\nUse hardware acceleration to decode the matching stream(s). The allowed values\nof hwaccel are:\n\nnone\nDo not use any hardware acceleration (the default).\n\n\nauto\nAutomatically select the hardware acceleration method.\n\n\nvdpau\nUse VDPAU (Video Decode and Presentation API for Unix) hardware acceleration.\n\n\ndxva2\nUse DXVA2 (DirectX Video Acceleration) hardware acceleration.\n\n\nd3d11va\nUse D3D11VA (DirectX Video Acceleration) hardware acceleration.\n\n\nvaapi\nUse VAAPI (Video Acceleration API) hardware acceleration.\n\n\nqsv\nUse the Intel QuickSync Video acceleration for video transcoding.\n\nUnlike most other values, this option does not enable accelerated decoding (that\nis used automatically whenever a qsv decoder is selected), but accelerated\ntranscoding, without copying the frames into the system memory.\n\nFor it to work, both the decoder and the encoder must support QSV acceleration\nand no filters must be used.\n\n\nThis option has no effect if the selected hwaccel is not available or not\nsupported by the chosen decoder.\n\nNote that most acceleration methods are intended for playback and will not be\nfaster than software decoding on modern CPUs. Additionally, ffmpeg\nwill usually need to copy the decoded frames from the GPU memory into the system\nmemory, resulting in further performance loss. This option is thus mainly\nuseful for testing.\n\n\n-hwaccel_device[:stream_specifier] hwaccel_device (input,per-stream)\nSelect a device to use for hardware acceleration.\n\nThis option only makes sense when the -hwaccel option is also specified.\nIt can either refer to an existing device created with -init_hw_device\nby name, or it can create a new device as if\n‘-init_hw_device’ type:hwaccel_device\nwere called immediately before.\n\n\n-hwaccels\nList all hardware acceleration components enabled in this build of ffmpeg.\nActual runtime availability depends on the hardware and its suitable driver\nbeing installed.\n\n\n-fix_sub_duration_heartbeat[:stream_specifier]\nSet a specific output video stream as the heartbeat stream according to which\nto split and push through currently in-progress subtitle upon receipt of a\nrandom access packet.\n\nThis lowers the latency of subtitles for which the end packet or the following\nsubtitle has not yet been received. As a drawback, this will most likely lead\nto duplication of subtitle events in order to cover the full duration, so\nwhen dealing with use cases where latency of when the subtitle event is passed\non to output is not relevant this option should not be utilized.\n\nRequires -fix_sub_duration to be set for the relevant input subtitle\nstream for this to have any effect, as well as for the input subtitle stream\nhaving to be directly mapped to the same output in which the heartbeat stream\nresides.\n\n\n\n",
		"5.7 Audio Options": "5.7 Audio Options\n\n-aframes number (output)\nSet the number of audio frames to output. This is an obsolete alias for\n-frames:a, which you should use instead.\n\n-ar[:stream_specifier] freq (input/output,per-stream)\nSet the audio sampling frequency. For output streams it is set by\ndefault to the frequency of the corresponding input stream. For input\nstreams this option only makes sense for audio grabbing devices and raw\ndemuxers and is mapped to the corresponding demuxer options.\n\n-aq q (output)\nSet the audio quality (codec-specific, VBR). This is an alias for -q:a.\n\n-ac[:stream_specifier] channels (input/output,per-stream)\nSet the number of audio channels. For output streams it is set by\ndefault to the number of input audio channels. For input streams\nthis option only makes sense for audio grabbing devices and raw demuxers\nand is mapped to the corresponding demuxer options.\n\n-an (input/output)\nAs an input option, blocks all audio streams of a file from being filtered or\nbeing automatically selected or mapped for any output. See -discard\noption to disable streams individually.\n\nAs an output option, disables audio recording i.e. automatic selection or\nmapping of any audio stream. For full manual control see the -map\noption.\n\n-acodec codec (input/output)\nSet the audio codec. This is an alias for -codec:a.\n\n-sample_fmt[:stream_specifier] sample_fmt (output,per-stream)\nSet the audio sample format. Use -sample_fmts to get a list\nof supported sample formats.\n\n\n-af filtergraph (output)\nCreate the filtergraph specified by filtergraph and use it to\nfilter the stream.\n\nThis is an alias for -filter:a, see the -filter option.\n\n\n",
		"5.8 Advanced Audio options": "5.8 Advanced Audio options\n\n-atag fourcc/tag (output)\nForce audio tag/fourcc. This is an alias for -tag:a.\n\n-ch_layout[:stream_specifier] layout (input/output,per-stream)\nAlias for -channel_layout.\n\n-channel_layout[:stream_specifier] layout (input/output,per-stream)\nSet the audio channel layout. For output streams it is set by default to the\ninput channel layout. For input streams it overrides the channel layout of the\ninput. Not all decoders respect the overridden channel layout. This option\nalso sets the channel layout for audio grabbing devices and raw demuxers\nand is mapped to the corresponding demuxer option.\n\n-guess_layout_max channels (input,per-stream)\nIf some input channel layout is not known, try to guess only if it\ncorresponds to at most the specified number of channels. For example, 2\ntells to ffmpeg to recognize 1 channel as mono and 2 channels as\nstereo but not 6 channels as 5.1. The default is to always try to guess. Use\n0 to disable all guessing. Using the -channel_layout option to\nexplicitly specify an input layout also disables guessing.\n\n\n",
		"5.9 Subtitle options": "5.9 Subtitle options\n\n-scodec codec (input/output)\nSet the subtitle codec. This is an alias for -codec:s.\n\n-sn (input/output)\nAs an input option, blocks all subtitle streams of a file from being filtered or\nbeing automatically selected or mapped for any output. See -discard\noption to disable streams individually.\n\nAs an output option, disables subtitle recording i.e. automatic selection or\nmapping of any subtitle stream. For full manual control see the -map\noption.\n\n\n",
		"5.10 Advanced Subtitle options": "5.10 Advanced Subtitle options\n\n-fix_sub_duration\nFix subtitles durations. For each subtitle, wait for the next packet in the\nsame stream and adjust the duration of the first to avoid overlap. This is\nnecessary with some subtitles codecs, especially DVB subtitles, because the\nduration in the original packet is only a rough estimate and the end is\nactually marked by an empty subtitle frame. Failing to use this option when\nnecessary can result in exaggerated durations or muxing failures due to\nnon-monotonic timestamps.\n\nNote that this option will delay the output of all data until the next\nsubtitle packet is decoded: it may increase memory consumption and latency a\nlot.\n\n\n-canvas_size size\nSet the size of the canvas used to render subtitles.\n\n\n\n",
		"5.11 Advanced options": "5.11 Advanced options\n\n-map [-]input_file_id[:stream_specifier][?] | [linklabel] (output)\n\nCreate one or more streams in the output file. This option has two forms for\nspecifying the data source(s): the first selects one or more streams from some\ninput file (specified with -i), the second takes an output from some\ncomplex filtergraph (specified with -filter_complex).\n\nIn the first form, an output stream is created for every stream from the input\nfile with the index input_file_id. If stream_specifier is given,\nonly those streams that match the specifier are used (see the\nStream specifiers section for the stream_specifier syntax).\n\nA - character before the stream identifier creates a \"negative\" mapping.\nIt disables matching streams from already created mappings.\n\nA trailing ? after the stream index will allow the map to be\noptional: if the map matches no streams the map will be ignored instead\nof failing. Note the map will still fail if an invalid input file index\nis used; such as if the map refers to a non-existent input.\n\nAn alternative [linklabel] form will map outputs from complex filter\ngraphs (see the -filter_complex option) to the output file.\nlinklabel must correspond to a defined output link label in the graph.\n\nThis option may be specified multiple times, each adding more streams to the\noutput file. Any given input stream may also be mapped any number of times as a\nsource for different output streams, e.g. in order to use different encoding\noptions and/or filters. The streams are created in the output in the same order\nin which the -map options are given on the commandline.\n\nUsing this option disables the default mappings for this output file.\n\nExamples:\n\n\nmap everything\nTo map ALL streams from the first input file to output\n\nffmpeg -i INPUT -map 0 output\n\n\nselect specific stream\nIf you have two audio streams in the first input file, these streams are\nidentified by 0:0 and 0:1. You can use -map to select which\nstreams to place in an output file. For example:\n\nffmpeg -i INPUT -map 0:1 out.wav\n\nwill map the second input stream in INPUT to the (single) output stream\nin out.wav.\n\n\ncreate multiple streams\nTo select the stream with index 2 from input file a.mov (specified by the\nidentifier 0:2), and stream with index 6 from input b.mov\n(specified by the identifier 1:6), and copy them to the output file\nout.mov:\n\nffmpeg -i a.mov -i b.mov -c copy -map 0:2 -map 1:6 out.mov\n\n\ncreate multiple streams 2\nTo select all video and the third audio stream from an input file:\n\nffmpeg -i INPUT -map 0:v -map 0:a:2 OUTPUT\n\n\nnegative map\nTo map all the streams except the second audio, use negative mappings\n\nffmpeg -i INPUT -map 0 -map -0:a:1 OUTPUT\n\n\noptional map\nTo map the video and audio streams from the first input, and using the\ntrailing ?, ignore the audio mapping if no audio streams exist in\nthe first input:\n\nffmpeg -i INPUT -map 0:v -map 0:a? OUTPUT\n\n\nmap by language\nTo pick the English audio stream:\n\nffmpeg -i INPUT -map 0:m:language:eng OUTPUT\n\n\n\n\n-ignore_unknown\nIgnore input streams with unknown type instead of failing if copying\nsuch streams is attempted.\n\n\n-copy_unknown\nAllow input streams with unknown type to be copied instead of failing if copying\nsuch streams is attempted.\n\n\n-map_metadata[:metadata_spec_out] infile[:metadata_spec_in] (output,per-metadata)\nSet metadata information of the next output file from infile. Note that\nthose are file indices (zero-based), not filenames.\nOptional metadata_spec_in/out parameters specify, which metadata to copy.\nA metadata specifier can have the following forms:\n\ng\nglobal metadata, i.e. metadata that applies to the whole file\n\n\ns[:stream_spec]\nper-stream metadata. stream_spec is a stream specifier as described\nin the Stream specifiers chapter. In an input metadata specifier, the first\nmatching stream is copied from. In an output metadata specifier, all matching\nstreams are copied to.\n\n\nc:chapter_index\nper-chapter metadata. chapter_index is the zero-based chapter index.\n\n\np:program_index\nper-program metadata. program_index is the zero-based program index.\n\n\nIf metadata specifier is omitted, it defaults to global.\n\nBy default, global metadata is copied from the first input file,\nper-stream and per-chapter metadata is copied along with streams/chapters. These\ndefault mappings are disabled by creating any mapping of the relevant type. A negative\nfile index can be used to create a dummy mapping that just disables automatic copying.\n\nFor example to copy metadata from the first stream of the input file to global metadata\nof the output file:\n\nffmpeg -i in.ogg -map_metadata 0:s:0 out.mp3\n\nTo do the reverse, i.e. copy global metadata to all audio streams:\n\nffmpeg -i in.mkv -map_metadata:s:a 0:g out.mkv\n\nNote that simple 0 would work as well in this example, since global\nmetadata is assumed by default.\n\n\n-map_chapters input_file_index (output)\nCopy chapters from input file with index input_file_index to the next\noutput file. If no chapter mapping is specified, then chapters are copied from\nthe first input file with at least one chapter. Use a negative file index to\ndisable any chapter copying.\n\n\n-benchmark (global)\nShow benchmarking information at the end of an encode.\nShows real, system and user time used and maximum memory consumption.\nMaximum memory consumption is not supported on all systems,\nit will usually display as 0 if not supported.\n\n-benchmark_all (global)\nShow benchmarking information during the encode.\nShows real, system and user time used in various steps (audio/video encode/decode).\n\n-timelimit duration (global)\nExit after ffmpeg has been running for duration seconds in CPU user time.\n\n-dump (global)\nDump each input packet to stderr.\n\n-hex (global)\nWhen dumping packets, also dump the payload.\n\n-readrate speed (input)\nLimit input read speed.\n\nIts value is a floating-point positive number which represents the maximum duration of\nmedia, in seconds, that should be ingested in one second of wallclock time.\nDefault value is zero and represents no imposed limitation on speed of ingestion.\nValue 1 represents real-time speed and is equivalent to -re.\n\nMainly used to simulate a capture device or live input stream (e.g. when reading from a file).\nShould not be used with a low value when input is an actual capture device or live stream as\nit may cause packet loss.\n\nIt is useful for when flow speed of output packets is important, such as live streaming.\n\n-re (input)\nRead input at native frame rate. This is equivalent to setting -readrate 1.\n\n-readrate_initial_burst seconds\nSet an initial read burst time, in seconds, after which -re/-readrate\nwill be enforced.\n\n-vsync parameter (global)\n-fps_mode[:stream_specifier] parameter (output,per-stream)\nSet video sync method / framerate mode. vsync is applied to all output video streams\nbut can be overridden for a stream by setting fps_mode. vsync is deprecated and will be\nremoved in the future.\n\nFor compatibility reasons some of the values for vsync can be specified as numbers (shown\nin parentheses in the following table).\n\n\npassthrough (0)\nEach frame is passed with its timestamp from the demuxer to the muxer.\n\ncfr (1)\nFrames will be duplicated and dropped to achieve exactly the requested\nconstant frame rate.\n\nvfr (2)\nFrames are passed through with their timestamp or dropped so as to\nprevent 2 frames from having the same timestamp.\n\nauto (-1)\nChooses between cfr and vfr depending on muxer capabilities. This is the\ndefault method.\n\n\nNote that the timestamps may be further modified by the muxer, after this.\nFor example, in the case that the format option avoid_negative_ts\nis enabled.\n\nWith -map you can select from which stream the timestamps should be\ntaken. You can leave either video or audio unchanged and sync the\nremaining stream(s) to the unchanged one.\n\n\n-frame_drop_threshold parameter\nFrame drop threshold, which specifies how much behind video frames can\nbe before they are dropped. In frame rate units, so 1.0 is one frame.\nThe default is -1.1. One possible usecase is to avoid framedrops in case\nof noisy timestamps or to increase frame drop precision in case of exact\ntimestamps.\n\n\n-apad parameters (output,per-stream)\nPad the output audio stream(s). This is the same as applying -af apad.\nArgument is a string of filter parameters composed the same as with the apad filter.\n-shortest must be set for this output for the option to take effect.\n\n\n-copyts\nDo not process input timestamps, but keep their values without trying\nto sanitize them. In particular, do not remove the initial start time\noffset value.\n\nNote that, depending on the vsync option or on specific muxer\nprocessing (e.g. in case the format option avoid_negative_ts\nis enabled) the output timestamps may mismatch with the input\ntimestamps even when this option is selected.\n\n\n-start_at_zero\nWhen used with copyts, shift input timestamps so they start at zero.\n\nThis means that using e.g. -ss 50 will make output timestamps start at\n50 seconds, regardless of what timestamp the input file started at.\n\n\n-copytb mode\nSpecify how to set the encoder timebase when stream copying.  mode is an\ninteger numeric value, and can assume one of the following values:\n\n\n1\nUse the demuxer timebase.\n\nThe time base is copied to the output encoder from the corresponding input\ndemuxer. This is sometimes required to avoid non monotonically increasing\ntimestamps when copying video streams with variable frame rate.\n\n\n0\nUse the decoder timebase.\n\nThe time base is copied to the output encoder from the corresponding input\ndecoder.\n\n\n-1\nTry to make the choice automatically, in order to generate a sane output.\n\n\nDefault value is -1.\n\n\n-enc_time_base[:stream_specifier] timebase (output,per-stream)\nSet the encoder timebase. timebase can assume one of the following values:\n\n\n0\nAssign a default value according to the media type.\n\nFor video - use 1/framerate, for audio - use 1/samplerate.\n\n\ndemux\nUse the timebase from the demuxer.\n\n\nfilter\nUse the timebase from the filtergraph.\n\n\na positive number\nUse the provided number as the timebase.\n\nThis field can be provided as a ratio of two integers (e.g. 1:24, 1:48000)\nor as a decimal number (e.g. 0.04166, 2.0833e-5)\n\n\nDefault value is 0.\n\n\n-bitexact (input/output)\nEnable bitexact mode for (de)muxer and (de/en)coder\n\n-shortest (output)\nFinish encoding when the shortest output stream ends.\n\nNote that this option may require buffering frames, which introduces extra\nlatency. The maximum amount of this latency may be controlled with the\n-shortest_buf_duration option.\n\n\n-shortest_buf_duration duration (output)\nThe -shortest option may require buffering potentially large amounts\nof data when at least one of the streams is \"sparse\" (i.e. has large gaps\nbetween frames – this is typically the case for subtitles).\n\nThis option controls the maximum duration of buffered frames in seconds.\nLarger values may allow the -shortest option to produce more accurate\nresults, but increase memory use and latency.\n\nThe default value is 10 seconds.\n\n\n-dts_delta_threshold threshold\nTimestamp discontinuity delta threshold, expressed as a decimal number\nof seconds.\n\nThe timestamp discontinuity correction enabled by this option is only\napplied to input formats accepting timestamp discontinuity (for which\nthe AVFMT_TS_DISCONT flag is enabled), e.g. MPEG-TS and HLS, and\nis automatically disabled when employing the -copyts option\n(unless wrapping is detected).\n\nIf a timestamp discontinuity is detected whose absolute value is\ngreater than threshold, ffmpeg will remove the discontinuity by\ndecreasing/increasing the current DTS and PTS by the corresponding\ndelta value.\n\nThe default value is 10.\n\n\n-dts_error_threshold threshold\nTimestamp error delta threshold, expressed as a decimal number of\nseconds.\n\nThe timestamp correction enabled by this option is only applied to\ninput formats not accepting timestamp discontinuity (for which the\nAVFMT_TS_DISCONT flag is not enabled).\n\nIf a timestamp discontinuity is detected whose absolute value is\ngreater than threshold, ffmpeg will drop the PTS/DTS timestamp\nvalue.\n\nThe default value is 3600*30 (30 hours), which is arbitrarily\npicked and quite conservative.\n\n\n-muxdelay seconds (output)\nSet the maximum demux-decode delay.\n\n-muxpreload seconds (output)\nSet the initial demux-decode delay.\n\n-streamid output-stream-index:new-value (output)\nAssign a new stream-id value to an output stream. This option should be\nspecified prior to the output filename to which it applies.\nFor the situation where multiple output files exist, a streamid\nmay be reassigned to a different value.\n\nFor example, to set the stream 0 PID to 33 and the stream 1 PID to 36 for\nan output mpegts file:\n\nffmpeg -i inurl -streamid 0:33 -streamid 1:36 out.ts\n\n\n-bsf[:stream_specifier] bitstream_filters (input/output,per-stream)\nApply bitstream filters to matching streams. The filters are applied to each\npacket as it is received from the demuxer (when used as an input option) or\nbefore it is sent to the muxer (when used as an output option).\n\nbitstream_filters is a comma-separated list of bitstream filter\nspecifications, each of the form\n\nfilter[=optname0=optval0:optname1=optval1:...]\n\nAny of the ’,=:’ characters that are to be a part of an option value need to be\nescaped with a backslash.\n\nUse the -bsfs option to get the list of bitstream filters.\n\nE.g.\n\nffmpeg -bsf:v h264_mp4toannexb -i h264.mp4 -c:v copy -an out.h264\n\napplies the h264_mp4toannexb bitstream filter (which converts\nMP4-encapsulated H.264 stream to Annex B) to the input video stream.\n\nOn the other hand,\n\nffmpeg -i file.mov -an -vn -bsf:s mov2textsub -c:s copy -f rawvideo sub.txt\n\napplies the mov2textsub bitstream filter (which extracts text from MOV\nsubtitles) to the output subtitle stream. Note, however, that since both\nexamples use -c copy, it matters little whether the filters are applied\non input or output - that would change if transcoding was happening.\n\n\n-tag[:stream_specifier] codec_tag (input/output,per-stream)\nForce a tag/fourcc for matching streams.\n\n\n-timecode hh:mm:ssSEPff\nSpecify Timecode for writing. SEP is ’:’ for non drop timecode and ’;’\n(or ’.’) for drop.\n\nffmpeg -i input.mpg -timecode 01:02:03.04 -r 30000/1001 -s ntsc output.mpg\n\n\n-filter_complex filtergraph (global)\nDefine a complex filtergraph, i.e. one with arbitrary number of inputs and/or\noutputs. For simple graphs – those with one input and one output of the same\ntype – see the -filter options. filtergraph is a description of\nthe filtergraph, as described in the “Filtergraph syntax” section of the\nffmpeg-filters manual. This option may be specified multiple times - each use\ncreates a new complex filtergraph.\n\nInputs to a complex filtergraph may come from different source types,\ndistinguished by the format of the corresponding link label:\n\n To connect an input stream, use [file_index:stream_specifier] (i.e. the\nsame syntax as -map). If stream_specifier matches multiple\nstreams, the first one will be used.\n\n To connect a loopback decoder use [dec:dec_idx], where dec_idx is\nthe index of the loopback decoder to be connected to given input.\n\n To connect an output from another complex filtergraph, use its link label. E.g\nthe following example:\n\n\nffmpeg -i input.mkv \\\n  -filter_complex '[0:v]scale=size=hd1080,split=outputs=2[for_enc][orig_scaled]' \\\n  -c:v libx264 -map '[for_enc]' output.mkv \\\n  -dec 0:0 \\\n  -filter_complex '[dec:0][orig_scaled]hstack[stacked]' \\\n  -map '[stacked]' -c:v ffv1 comparison.mkv\n\nreads an input video and\n\n (line 2) uses a complex filtergraph with one input and two outputs\nto scale the video to 1920x1080 and duplicate the result to both\noutputs;\n\n (line 3) encodes one scaled output with libx264 and writes the result to\noutput.mkv;\n\n (line 4) decodes this encoded stream with a loopback decoder;\n\n (line 5) places the output of the loopback decoder (i.e. the\nlibx264-encoded video) side by side with the scaled original input;\n\n (line 6) combined video is then losslessly encoded and written into\ncomparison.mkv.\n\n\nNote that the two filtergraphs cannot be combined into one, because then there\nwould be a cycle in the transcoding pipeline (filtergraph output goes to\nencoding, from there to decoding, then back to the same graph), and such cycles\nare not allowed.\n\n\nAn unlabeled input will be connected to the first unused input stream of the\nmatching type.\n\nOutput link labels are referred to with -map. Unlabeled outputs are\nadded to the first output file.\n\nNote that with this option it is possible to use only lavfi sources without\nnormal input files.\n\nFor example, to overlay an image over video\n\nffmpeg -i video.mkv -i image.png -filter_complex '[0:v][1:v]overlay[out]' -map\n'[out]' out.mkv\n\nHere [0:v] refers to the first video stream in the first input file,\nwhich is linked to the first (main) input of the overlay filter. Similarly the\nfirst video stream in the second input is linked to the second (overlay) input\nof overlay.\n\nAssuming there is only one video stream in each input file, we can omit input\nlabels, so the above is equivalent to\n\nffmpeg -i video.mkv -i image.png -filter_complex 'overlay[out]' -map\n'[out]' out.mkv\n\nFurthermore we can omit the output label and the single output from the filter\ngraph will be added to the output file automatically, so we can simply write\n\nffmpeg -i video.mkv -i image.png -filter_complex 'overlay' out.mkv\n\nAs a special exception, you can use a bitmap subtitle stream as input: it\nwill be converted into a video with the same size as the largest video in\nthe file, or 720x576 if no video is present. Note that this is an\nexperimental and temporary solution. It will be removed once libavfilter has\nproper support for subtitles.\n\nFor example, to hardcode subtitles on top of a DVB-T recording stored in\nMPEG-TS format, delaying the subtitles by 1 second:\n\nffmpeg -i input.ts -filter_complex \\\n  '[#0x2ef] setpts=PTS+1/TB [sub] ; [#0x2d0] [sub] overlay' \\\n  -sn -map '#0x2dc' output.mkv\n\n(0x2d0, 0x2dc and 0x2ef are the MPEG-TS PIDs of respectively the video,\naudio and subtitles streams; 0:0, 0:3 and 0:7 would have worked too)\n\nTo generate 5 seconds of pure red video using lavfi color source:\n\nffmpeg -filter_complex 'color=c=red' -t 5 out.mkv\n\n\n-filter_complex_threads nb_threads (global)\nDefines how many threads are used to process a filter_complex graph.\nSimilar to filter_threads but used for -filter_complex graphs only.\nThe default is the number of available CPUs.\n\n\n-lavfi filtergraph (global)\nDefine a complex filtergraph, i.e. one with arbitrary number of inputs and/or\noutputs. Equivalent to -filter_complex.\n\n\n-accurate_seek (input)\nThis option enables or disables accurate seeking in input files with the\n-ss option. It is enabled by default, so seeking is accurate when\ntranscoding. Use -noaccurate_seek to disable it, which may be useful\ne.g. when copying some streams and transcoding the others.\n\n\n-seek_timestamp (input)\nThis option enables or disables seeking by timestamp in input files with the\n-ss option. It is disabled by default. If enabled, the argument\nto the -ss option is considered an actual timestamp, and is not\noffset by the start time of the file. This matters only for files which do\nnot start from timestamp 0, such as transport streams.\n\n\n-thread_queue_size size (input/output)\nFor input, this option sets the maximum number of queued packets when reading\nfrom the file or device. With low latency / high rate live streams, packets may\nbe discarded if they are not read in a timely manner; setting this value can\nforce ffmpeg to use a separate input thread and read packets as soon as they\narrive. By default ffmpeg only does this if multiple inputs are specified.\n\nFor output, this option specified the maximum number of packets that may be\nqueued to each muxing thread.\n\n\n-sdp_file file (global)\nPrint sdp information for an output stream to file.\nThis allows dumping sdp information when at least one output isn’t an\nrtp stream. (Requires at least one of the output formats to be rtp).\n\n\n-discard (input)\nAllows discarding specific streams or frames from streams.\nAny input stream can be fully discarded, using value all whereas\nselective discarding of frames from a stream occurs at the demuxer\nand is not supported by all demuxers.\n\n\nnone\nDiscard no frame.\n\n\ndefault\nDefault, which discards no frames.\n\n\nnoref\nDiscard all non-reference frames.\n\n\nbidir\nDiscard all bidirectional frames.\n\n\nnokey\nDiscard all frames excepts keyframes.\n\n\nall\nDiscard all frames.\n\n\n\n-abort_on flags (global)\nStop and abort on various conditions. The following flags are available:\n\n\nempty_output\nNo packets were passed to the muxer, the output is empty.\n\nempty_output_stream\nNo packets were passed to the muxer in some of the output streams.\n\n\n\n-max_error_rate (global)\nSet fraction of decoding frame failures across all inputs which when crossed\nffmpeg will return exit code 69. Crossing this threshold does not terminate\nprocessing. Range is a floating-point number between 0 to 1. Default is 2/3.\n\n\n-xerror (global)\nStop and exit on error\n\n\n-max_muxing_queue_size packets (output,per-stream)\nWhen transcoding audio and/or video streams, ffmpeg will not begin writing into\nthe output until it has one packet for each such stream. While waiting for that\nto happen, packets for other streams are buffered. This option sets the size of\nthis buffer, in packets, for the matching output stream.\n\nThe default value of this option should be high enough for most uses, so only\ntouch this option if you are sure that you need it.\n\n\n-muxing_queue_data_threshold bytes (output,per-stream)\nThis is a minimum threshold until which the muxing queue size is not taken into\naccount. Defaults to 50 megabytes per stream, and is based on the overall size\nof packets passed to the muxer.\n\n\n-auto_conversion_filters (global)\nEnable automatically inserting format conversion filters in all filter\ngraphs, including those defined by -vf, -af,\n-filter_complex and -lavfi. If filter format negotiation\nrequires a conversion, the initialization of the filters will fail.\nConversions can still be performed by inserting the relevant conversion\nfilter (scale, aresample) in the graph.\nOn by default, to explicitly disable it you need to specify\n-noauto_conversion_filters.\n\n\n-bits_per_raw_sample[:stream_specifier] value (output,per-stream)\nDeclare the number of bits per raw sample in the given output stream to be\nvalue. Note that this option sets the information provided to the\nencoder/muxer, it does not change the stream to conform to this value. Setting\nvalues that do not match the stream properties may result in encoding failures\nor invalid output files.\n\n\n-stats_enc_pre[:stream_specifier] path (output,per-stream)\n-stats_enc_post[:stream_specifier] path (output,per-stream)\n-stats_mux_pre[:stream_specifier] path (output,per-stream)\nWrite per-frame encoding information about the matching streams into the file\ngiven by path.\n\n-stats_enc_pre writes information about raw video or audio frames right\nbefore they are sent for encoding, while -stats_enc_post writes\ninformation about encoded packets as they are received from the encoder.\n-stats_mux_pre writes information about packets just as they are about to\nbe sent to the muxer. Every frame or packet produces one line in the specified\nfile. The format of this line is controlled by -stats_enc_pre_fmt /\n-stats_enc_post_fmt / -stats_mux_pre_fmt.\n\nWhen stats for multiple streams are written into a single file, the lines\ncorresponding to different streams will be interleaved. The precise order of\nthis interleaving is not specified and not guaranteed to remain stable between\ndifferent invocations of the program, even with the same options.\n\n\n-stats_enc_pre_fmt[:stream_specifier] format_spec (output,per-stream)\n-stats_enc_post_fmt[:stream_specifier] format_spec (output,per-stream)\n-stats_mux_pre_fmt[:stream_specifier] format_spec (output,per-stream)\nSpecify the format for the lines written with -stats_enc_pre /\n-stats_enc_post / -stats_mux_pre.\n\nformat_spec is a string that may contain directives of the form\n{fmt}. format_spec is backslash-escaped — use \\{, \\}, and \\\\\nto write a literal {, }, or \\, respectively, into the output.\n\nThe directives given with fmt may be one of the following:\n\nfidx\nIndex of the output file.\n\n\nsidx\nIndex of the output stream in the file.\n\n\nn\nFrame number. Pre-encoding: number of frames sent to the encoder so far.\nPost-encoding: number of packets received from the encoder so far.\nMuxing: number of packets submitted to the muxer for this stream so far.\n\n\nni\nInput frame number. Index of the input frame (i.e. output by a decoder) that\ncorresponds to this output frame or packet. -1 if unavailable.\n\n\ntb\nTimebase in which this frame/packet’s timestamps are expressed, as a rational\nnumber num/den. Note that encoder and muxer may use different timebases.\n\n\ntbi\nTimebase for ptsi, as a rational number num/den. Available when\nptsi is available, 0/1 otherwise.\n\n\npts\nPresentation timestamp of the frame or packet, as an integer. Should be\nmultiplied by the timebase to compute presentation time.\n\n\nptsi\nPresentation timestamp of the input frame (see ni), as an integer. Should\nbe multiplied by tbi to compute presentation time. Printed as\n(2^63 - 1 = 9223372036854775807) when not available.\n\n\nt\nPresentation time of the frame or packet, as a decimal number. Equal to\npts multiplied by tb.\n\n\nti\nPresentation time of the input frame (see ni), as a decimal number. Equal\nto ptsi multiplied by tbi. Printed as inf when not available.\n\n\ndts (packet)\nDecoding timestamp of the packet, as an integer. Should be multiplied by the\ntimebase to compute presentation time.\n\n\ndt (packet)\nDecoding time of the frame or packet, as a decimal number. Equal to\ndts multiplied by tb.\n\n\nsn (frame,audio)\nNumber of audio samples sent to the encoder so far.\n\n\nsamp (frame,audio)\nNumber of audio samples in the frame.\n\n\nsize (packet)\nSize of the encoded packet in bytes.\n\n\nbr (packet)\nCurrent bitrate in bits per second.\n\n\nabr (packet)\nAverage bitrate for the whole stream so far, in bits per second, -1 if it cannot\nbe determined at this point.\n\n\nkey (packet)\nCharacter ’K’ if the packet contains a keyframe, character ’N’ otherwise.\n\n\nDirectives tagged with packet may only be used with\n-stats_enc_post_fmt and -stats_mux_pre_fmt.\n\nDirectives tagged with frame may only be used with\n-stats_enc_pre_fmt.\n\nDirectives tagged with audio may only be used with audio streams.\n\nThe default format strings are:\n\npre-encoding\n{fidx} {sidx} {n} {t}\n\npost-encoding\n{fidx} {sidx} {n} {t}\n\n\nIn the future, new items may be added to the end of the default formatting\nstrings. Users who depend on the format staying exactly the same, should\nprescribe it manually.\n\nNote that stats for different streams written into the same file may have\ndifferent formats.\n\n\n\n",
		"5.12 Preset files": "5.12 Preset files\nA preset file contains a sequence of option=value pairs,\none for each line, specifying a sequence of options which would be\nawkward to specify on the command line. Lines starting with the hash\n(’#’) character are ignored and are used to provide comments. Check\nthe presets directory in the FFmpeg source tree for examples.\n\nThere are two types of preset files: ffpreset and avpreset files.\n\n\n5.12.1 ffpreset files\nffpreset files are specified with the vpre, apre,\nspre, and fpre options. The fpre option takes the\nfilename of the preset instead of a preset name as input and can be\nused for any kind of codec. For the vpre, apre, and\nspre options, the options specified in a preset file are\napplied to the currently selected codec of the same type as the preset\noption.\n\nThe argument passed to the vpre, apre, and spre\npreset options identifies the preset file to use according to the\nfollowing rules:\n\nFirst ffmpeg searches for a file named arg.ffpreset in the\ndirectories $FFMPEG_DATADIR (if set), and $HOME/.ffmpeg, and in\nthe datadir defined at configuration time (usually PREFIX/share/ffmpeg)\nor in a ffpresets folder along the executable on win32,\nin that order. For example, if the argument is libvpx-1080p, it will\nsearch for the file libvpx-1080p.ffpreset.\n\nIf no such file is found, then ffmpeg will search for a file named\ncodec_name-arg.ffpreset in the above-mentioned\ndirectories, where codec_name is the name of the codec to which\nthe preset file options will be applied. For example, if you select\nthe video codec with -vcodec libvpx and use -vpre 1080p,\nthen it will search for the file libvpx-1080p.ffpreset.\n\n\n5.12.2 avpreset files\navpreset files are specified with the pre option. They work similar to\nffpreset files, but they only allow encoder- specific options. Therefore, an\noption=value pair specifying an encoder cannot be used.\n\nWhen the pre option is specified, ffmpeg will look for files with the\nsuffix .avpreset in the directories $AVCONV_DATADIR (if set), and\n$HOME/.avconv, and in the datadir defined at configuration time (usually\nPREFIX/share/ffmpeg), in that order.\n\nFirst ffmpeg searches for a file named codec_name-arg.avpreset in\nthe above-mentioned directories, where codec_name is the name of the codec\nto which the preset file options will be applied. For example, if you select the\nvideo codec with -vcodec libvpx and use -pre 1080p, then it will\nsearch for the file libvpx-1080p.avpreset.\n\nIf no such file is found, then ffmpeg will search for a file named\narg.avpreset in the same directories.\n\n\n",
		"5.13 vstats file format": "5.13 vstats file format\nThe -vstats and -vstats_file options enable generation of a file\ncontaining statistics about the generated video outputs.\n\nThe -vstats_version option controls the format version of the generated\nfile.\n\nWith version 1 the format is:\n\n\nframe= FRAME q= FRAME_QUALITY PSNR= PSNR f_size= FRAME_SIZE s_size= STREAM_SIZEkB time= TIMESTAMP br= BITRATEkbits/s avg_br= AVERAGE_BITRATEkbits/s\n\nWith version 2 the format is:\n\n\nout= OUT_FILE_INDEX st= OUT_FILE_STREAM_INDEX frame= FRAME_NUMBER q= FRAME_QUALITYf PSNR= PSNR f_size= FRAME_SIZE s_size= STREAM_SIZEkB time= TIMESTAMP br= BITRATEkbits/s avg_br= AVERAGE_BITRATEkbits/s\n\nThe value corresponding to each key is described below:\n\n\navg_br\naverage bitrate expressed in Kbits/s\n\n\nbr\nbitrate expressed in Kbits/s\n\n\nframe\nnumber of encoded frame\n\n\nout\nout file index\n\n\nPSNR\nPeak Signal to Noise Ratio\n\n\nq\nquality of the frame\n\n\nf_size\nencoded packet size expressed as number of bytes\n\n\ns_size\nstream size expressed in KiB\n\n\nst\nout file stream index\n\n\ntime\ntime of the packet\n\n\ntype\npicture type\n\n\nSee also the -stats_enc options for an alternative way\nto show encoding statistics.\n\n"
	},
	{
		"6 Examples": "6 Examples\n",
		"6.1 Video and Audio grabbing": "6.1 Video and Audio grabbing\nIf you specify the input format and device then ffmpeg can grab video\nand audio directly.\n\n\nffmpeg -f oss -i /dev/dsp -f video4linux2 -i /dev/video0 /tmp/out.mpg\n\nOr with an ALSA audio source (mono input, card id 1) instead of OSS:\n\n\nffmpeg -f alsa -ac 1 -i hw:1 -f video4linux2 -i /dev/video0 /tmp/out.mpg\n\nNote that you must activate the right video source and channel before\nlaunching ffmpeg with any TV viewer such as\nxawtv by Gerd Knorr. You also\nhave to set the audio recording levels correctly with a\nstandard mixer.\n\n",
		"6.2 X11 grabbing": "6.2 X11 grabbing\nGrab the X11 display with ffmpeg via\n\n\nffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0 /tmp/out.mpg\n\n0.0 is display.screen number of your X11 server, same as\nthe DISPLAY environment variable.\n\n\nffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0+10,20 /tmp/out.mpg\n\n0.0 is display.screen number of your X11 server, same as the DISPLAY environment\nvariable. 10 is the x-offset and 20 the y-offset for the grabbing.\n\n",
		"6.3 Video and Audio file format conversion": "6.3 Video and Audio file format conversion\nAny supported file format and protocol can serve as input to ffmpeg:\n\nExamples:\n\n\n You can use YUV files as input:\n\n\nffmpeg -i /tmp/test%d.Y /tmp/out.mpg\n\nIt will use the files:\n\n/tmp/test0.Y, /tmp/test0.U, /tmp/test0.V,\n/tmp/test1.Y, /tmp/test1.U, /tmp/test1.V, etc...\n\nThe Y files use twice the resolution of the U and V files. They are\nraw files, without header. They can be generated by all decent video\ndecoders. You must specify the size of the image with the -s option\nif ffmpeg cannot guess it.\n\n You can input from a raw YUV420P file:\n\n\nffmpeg -i /tmp/test.yuv /tmp/out.avi\n\ntest.yuv is a file containing raw YUV planar data. Each frame is composed\nof the Y plane followed by the U and V planes at half vertical and\nhorizontal resolution.\n\n You can output to a raw YUV420P file:\n\n\nffmpeg -i mydivx.avi hugefile.yuv\n\n You can set several input files and output files:\n\n\nffmpeg -i /tmp/a.wav -s 640x480 -i /tmp/a.yuv /tmp/a.mpg\n\nConverts the audio file a.wav and the raw YUV video file a.yuv\nto MPEG file a.mpg.\n\n You can also do audio and video conversions at the same time:\n\n\nffmpeg -i /tmp/a.wav -ar 22050 /tmp/a.mp2\n\nConverts a.wav to MPEG audio at 22050 Hz sample rate.\n\n You can encode to several formats at the same time and define a\nmapping from input stream to output streams:\n\n\nffmpeg -i /tmp/a.wav -map 0:a -b:a 64k /tmp/a.mp2 -map 0:a -b:a 128k /tmp/b.mp2\n\nConverts a.wav to a.mp2 at 64 kbits and to b.mp2 at 128 kbits. ’-map\nfile:index’ specifies which input stream is used for each output\nstream, in the order of the definition of output streams.\n\n You can transcode decrypted VOBs:\n\n\nffmpeg -i snatch_1.vob -f avi -c:v mpeg4 -b:v 800k -g 300 -bf 2 -c:a libmp3lame -b:a 128k snatch.avi\n\nThis is a typical DVD ripping example; the input is a VOB file, the\noutput an AVI file with MPEG-4 video and MP3 audio. Note that in this\ncommand we use B-frames so the MPEG-4 stream is DivX5 compatible, and\nGOP size is 300 which means one intra frame every 10 seconds for 29.97fps\ninput video. Furthermore, the audio stream is MP3-encoded so you need\nto enable LAME support by passing --enable-libmp3lame to configure.\nThe mapping is particularly useful for DVD transcoding\nto get the desired audio language.\n\nNOTE: To see the supported input formats, use ffmpeg -demuxers.\n\n You can extract images from a video, or create a video from many images:\n\nFor extracting images from a video:\n\nffmpeg -i foo.avi -r 1 -s WxH -f image2 foo-%03d.jpeg\n\nThis will extract one video frame per second from the video and will\noutput them in files named foo-001.jpeg, foo-002.jpeg,\netc. Images will be rescaled to fit the new WxH values.\n\nIf you want to extract just a limited number of frames, you can use the\nabove command in combination with the -frames:v or -t option,\nor in combination with -ss to start extracting from a certain point in time.\n\nFor creating a video from many images:\n\nffmpeg -f image2 -framerate 12 -i foo-%03d.jpeg -s WxH foo.avi\n\nThe syntax foo-%03d.jpeg specifies to use a decimal number\ncomposed of three digits padded with zeroes to express the sequence\nnumber. It is the same syntax supported by the C printf function, but\nonly formats accepting a normal integer are suitable.\n\nWhen importing an image sequence, -i also supports expanding\nshell-like wildcard patterns (globbing) internally, by selecting the\nimage2-specific -pattern_type glob option.\n\nFor example, for creating a video from filenames matching the glob pattern\nfoo-*.jpeg:\n\nffmpeg -f image2 -pattern_type glob -framerate 12 -i 'foo-*.jpeg' -s WxH foo.avi\n\n You can put many streams of the same type in the output:\n\n\nffmpeg -i test1.avi -i test2.avi -map 1:1 -map 1:0 -map 0:1 -map 0:0 -c copy -y test12.nut\n\nThe resulting output file test12.nut will contain the first four streams\nfrom the input files in reverse order.\n\n To force CBR video output:\n\nffmpeg -i myfile.avi -b 4000k -minrate 4000k -maxrate 4000k -bufsize 1835k out.m2v\n\n The four options lmin, lmax, mblmin and mblmax use ’lambda’ units,\nbut you may use the QP2LAMBDA constant to easily convert from ’q’ units:\n\nffmpeg -i src.ext -lmax 21*QP2LAMBDA dst.ext\n\n\n"
	},
	{
		"section": "7 See Also\nffmpeg-all,\nffplay, ffprobe,\nffmpeg-utils,\nffmpeg-scaler,\nffmpeg-resampler,\nffmpeg-codecs,\nffmpeg-bitstream-filters,\nffmpeg-formats,\nffmpeg-devices,\nffmpeg-protocols,\nffmpeg-filters\n\n"
	},
	{
		"section": "8 Authors\nThe FFmpeg developers.\n\nFor details about the authorship, see the Git history of the project\n(https://git.ffmpeg.org/ffmpeg), e.g. by typing the command\ngit log in the FFmpeg source directory, or browsing the\nonline repository at https://git.ffmpeg.org/ffmpeg.\n\nMaintainers for the specific components are listed in the file\nMAINTAINERS in the source code tree.\n\n\n        This document was generated on June 7, 2024 using makeinfo.\n      \nHosting provided by telepoint.bg"
	}
]